<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Presentation API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Presentation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import tkinter as tk
import time
from tkinter import ttk
from tkinter import messagebox
import threading
import datetime


# font &#39;Verdana&#39; with medium size
MEDIUMFONT = (&#34;Verdana&#34;, 15)

# font &#39;Verdana&#39; with large size
LARGEFONT = (&#34;Verdana&#34;, 30)



class AuthPageToken(tk.Frame):
    &#34;&#34;&#34;Page for signing in to the system. This is the entry page of the application
    &#34;&#34;&#34;
    def __init__(self, master, controller):
        &#34;&#34;&#34;Construct the object

        Args:
            master (tk.Frame): the container frame
            controller (AppRoot): the controller of the app
        &#34;&#34;&#34;
        tk.Frame.__init__(self, master)
        
        self.master = master
        self.controller = controller
        self.configure(bg=&#34;#f0f0f0&#34;)
        self.create_widgets()           # call the function that create the graphical elements


    def create_widgets(self):
        &#34;&#34;&#34;create the graphical elements and define their properties
        &#34;&#34;&#34;
        # Create headline
        headline_label = ttk.Label(self, text=&#34;Tic Tac Toe&#34;, font=LARGEFONT, background=&#39;#F0F0F0&#39;, foreground=&#39;#333333&#39;)
        headline_label.pack(pady=10)
        
        # Group auth objects
        detailsFrame = tk.Frame(self, bg=&#34;#F0F0F0&#34;, highlightbackground=&#34;#F0F0F0&#34;, highlightthickness=0)
        detailsFrame.place(relx=0.5, rely=0.5, anchor=&#34;center&#34;)

        # Create token label and token entry
        token_label = ttk.Label(detailsFrame, text=&#34;Enter Your Token: &#34;, font=MEDIUMFONT, background=&#39;#F0F0F0&#39;, foreground=&#39;#333333&#39;)
        token_label.grid(row=0, column=0, pady=(0, 20), sticky=&#34;e&#34;)
        self.token_entry = tk.Entry(detailsFrame, font=(&#34;Verdana&#34;, 18))
        self.token_entry.grid(row=0, column=1, pady=(0, 20), sticky=&#34;w&#34;)
        self.token_entry.focus_set()
        
        # Create login button
        self.login_button = tk.Button(detailsFrame, text=&#34;Log in&#34;, command=self.authenticate, font=(&#34;Verdana&#34;, 18), bg=&#39;#4CAF50&#39;, fg=&#39;white&#39;)
        self.login_button.grid(row=2, column=0, columnspan=2, pady=(20, 50), sticky=&#34;n&#34;)
        
        # Message label
        self.message_label = ttk.Label(detailsFrame, text=&#34;&#34;, font=MEDIUMFONT, background=&#39;#F0F0F0&#39;, foreground=&#39;#333333&#39;)
        self.message_label.grid(row=3, column=0, pady=(0, 20), sticky=&#34;e&#34;)
        

        # Create Exit button
        exit_button = tk.Button(self, text=&#34; Exit &#34;, command=self.exitTheGame, font=(&#34;Verdana&#34;, 18), bg=&#39;#4CAF50&#39;, fg=&#39;white&#39;)
        exit_button.place(relx=0.6, rely=0.9)

        
        # Create Sign Up button
        signup_button = tk.Button(self, text=&#34;Sign Up&#34;, command=lambda: self.controller.show_page(SignUpPage), font=(&#34;Verdana&#34;, 18), bg=&#39;#4CAF50&#39;, fg=&#39;white&#39;)
        signup_button.place(relx=0.3, rely=0.9)

    
    def authenticate(self):
        &#34;&#34;&#34;manage the authentication process using unique token
        &#34;&#34;&#34;
        self.message_label.config(text = &#34;&#34;)        # clear the message label, just in case
        self.login_button[&#34;state&#34;] = &#34;disabled&#34;     # disable the &#39;login&#39; button until an answer from the server will be received
        
        token = self.token_entry.get()              # get the &#39;token&#39; input of the user
        self.controller.messageChannel.setRequest(&#34;veteranUser&#34;, token) # send a request to check validity of the token

        t = threading.Thread(target=self.authenticate_helper)
        t.start()

        # check periodically for a response from the server and handle a response in &#39;check_if_auth_done&#39;
        schedule_check(self, t, self.check_if_auth_done.__name__)


    def authenticate_helper(self):
        &#34;&#34;&#34;check if a response from the server about the &#39;auth&#39; request has arrived.
            At first we check if the response is None, i.e. no response has arrived, and then we verify
            that the response is what we expected to, i.e. &#34;response&#34; == &#34;0_verified&#34;, else we continue looping.
        &#34;&#34;&#34;
        while (self.controller.messageChannel.responses == []  or
               self.controller.messageChannel.responses[0][&#34;response&#34;][0] != &#34;0&#34;):
            pass


    def check_if_auth_done(self, t):
        &#34;&#34;&#34;if the thread &#39;t&#39; is dead then it means a response from the server about the auth request has arrived,
            the function handle that response

        Args:
            t (Thread): the thread that is in charge of checking if an auth response has arrived
        &#34;&#34;&#34;
        # If the thread has finished, re-enable the button and show a message.
        if not t.is_alive():
            self.login_button[&#34;state&#34;] = &#34;normal&#34;  # re-enable the button
            match self.controller.messageChannel.responses[0][&#34;response&#34;]: # examine the response
                # the user token is a verified user, move to the next frame
                case &#34;0_verified&#34;:
                    if self.controller.currentPage is AuthPageToken:
                        self.controller.show_page(MainPage)
                
                # the user is already registered, refuse the request for this process
                case &#34;0_AlreadyRegistered&#34;:
                    self.message_label.config(text = &#34;this user is already registered&#34;)
                
                # there is no token like the user inserted in the database
                case &#34;0_tokenNotFound&#34;:
                    self.message_label.config(text = &#34;this token was not found&#34;)
            
            # pop the response from the queue of responses
            self.controller.messageChannel.responses.pop(0)

        else:
            # Otherwise check again after one second
            schedule_check(self, t, self.check_if_auth_done.__name__)


    def exitTheGame(self):
        &#34;&#34;&#34;upon clicking the &#39;exit&#39; button, handle exiting the game gracefully by sending a message
            to the server
        &#34;&#34;&#34;
        self.controller.messageChannel.setRequest(&#34;exit&#34;, &#34;a&#34;)



class SignUpPage(tk.Frame):
    &#34;&#34;&#34;Page for registering new user to the system
    &#34;&#34;&#34;
    def __init__(self, parent, controller):
        &#34;&#34;&#34;constructor for SignUpPage

        Args:
            parent (tk.Frame): a frame that inherits from the app root
            controller (AppRoot): the controller of the app
        &#34;&#34;&#34;
        tk.Frame.__init__(self, parent)

        self.parent = parent
        self.controller = controller

        self.create_widgets()  # call the function that create the graphical elements

    def create_widgets(self):
        &#34;&#34;&#34;create the graphical elements and define their properties
        &#34;&#34;&#34;
        # Create headline
        headline_label = ttk.Label(self, text=&#34;Tic Tac Toe&#34;, font=LARGEFONT, background=&#39;#F0F0F0&#39;, foreground=&#39;#333333&#39;)
        headline_label.pack(pady=10)

        # Group auth objects 
        detailsFrame = tk.Frame(self, bg=&#34;#F0F0F0&#34;, highlightbackground=&#34;#F0F0F0&#34;, highlightthickness=0)
        detailsFrame.place(relx=0.5, rely=0.5, anchor=&#34;center&#34;)
        
        # Choose nikname
        nikName_label = ttk.Label(detailsFrame, text=&#34;Enter Your Nik Name: &#34;, font=MEDIUMFONT, background=&#39;#F0F0F0&#39;, foreground=&#39;#333333&#39;)
        nikName_label.grid(row=0, column=0, pady=(0, 20), sticky=&#34;e&#34;)
        self.nikName_entry = tk.Entry(detailsFrame, font=(&#34;Verdana&#34;, 18))
        self.nikName_entry.grid(row=0, column=1, pady=(0, 20), sticky=&#34;w&#34;)
        self.nikName_entry.focus_set()

        # &#39;Create User&#39; button
        self.createUser_button = tk.Button(detailsFrame, text=&#34;Create New User&#34;, command=self.createUser, font=(&#34;Verdana&#34;, 18), bg=&#39;#4CAF50&#39;, fg=&#39;white&#39;)
        self.createUser_button.grid(row=1, column=0, columnspan=2, pady=(20, 50), sticky=&#34;n&#34;)

        # &#39;New Token&#39; label
        self.token_label1 = ttk.Label(detailsFrame, text=&#34;Your unique token is:&#34;, font=MEDIUMFONT, background=&#39;#F0F0F0&#39;, foreground=&#39;#333333&#39;)
        self.token_label1.grid(row=2, column=0, columnspan=2, pady=(20, 50), sticky=&#34;w&#34;)
        self.token_label1.grid_forget()
        
        # actual token label
        self.token_label2 = ttk.Label(detailsFrame, text=&#34;_______&#34;, font=MEDIUMFONT, background=&#39;#F0F0F0&#39;, foreground=&#39;#333333&#39;)
        self.token_label2.grid(row=2, column=1, columnspan=2, pady=(20, 50), sticky=&#34;w&#34;)
        self.token_label2.grid_forget()


        # Create Exit button
        exit_button = tk.Button(self, text=&#34; Exit &#34;, command=self.exitTheGame, font=(&#34;Verdana&#34;, 18), bg=&#39;#4CAF50&#39;, fg=&#39;white&#39;)
        exit_button.place(relx=0.6, rely=0.9)

        
        # Create Sign In button
        signIn_button = tk.Button(self, text=&#34;Sign In&#34;, command=lambda: self.controller.show_page(AuthPageToken), font=(&#34;Verdana&#34;, 18), bg=&#39;#4CAF50&#39;, fg=&#39;white&#39;)
        signIn_button.place(relx=0.3, rely=0.9)


    def createUser(self):
        &#34;&#34;&#34;create new user by generating unique token and binding the chosen nik name to it
        &#34;&#34;&#34;
        # force the user to choose a nik name
        if self.nikName_entry.get() == &#34;&#34;: 
                messagebox.showinfo(&#34;nik name missing&#34;, &#34;You have to insert a NikName!&#34;)

        else:
            # first click on the button. If the request is granted then the text will be changed to &#39;start&#39;
            if self.createUser_button.cget(&#39;text&#39;) ==  &#34;Create New User&#34;: 
                self.createUser_button[&#34;state&#34;] = &#34;disabled&#34;                  # disable the button until we get a response from the server
                nikName = self.nikName_entry.get()                            # get the nik name the user chose
                self.controller.messageChannel.setRequest(&#34;newUser&#34;, nikName) # send a request of &#39;newUser&#39; to the server
                
                t = threading.Thread(target=self.signUp_helper)
                t.start()
                # check periodically for a response from the server and handle a response in &#39;check_if_signUp_done&#39;
                schedule_check(self, t, self.check_if_signUp_done.__name__)


            # click on the button when its text is &#39;start&#39; (second click), continue to the Main page
            else:
                self.controller.show_page(MainPage)

        
    def signUp_helper(self):
        &#34;&#34;&#34;check if a response from the server about the signUp request has arrived.
            At first we check if the response is None i.e. no response has arrived, and then we verify
            that the response is what we expected to, i.e. &#34;response&#34; == &#34;1_newUser&#34;, else we continue looping.
        &#34;&#34;&#34;
        while (self.controller.messageChannel.responses == []  or  
               self.controller.messageChannel.responses[0][&#34;response&#34;][0] != &#34;1&#34;):
            pass


    def check_if_signUp_done(self, t):
        &#34;&#34;&#34;if the thread &#39;t&#39; is dead then it means a response from the server about the auth request has arrived,
            the function handle that response
        Args:
            t (Thread): the thread that is in charge of checking if a signUp response has arrived
        &#34;&#34;&#34;
        # If the thread has finished, re-enable the button and show a message.
        if not t.is_alive():
            self.createUser_button.config(text=&#34;continue&#34;)
            self.createUser_button[&#34;state&#34;] = &#34;normal&#34; # a resposne has arrived so enable the button

            match self.controller.messageChannel.responses[0][&#34;response&#34;]: # examine the response
                # a request for a new user has granted
                case &#34;1_newUser&#34;:
                    if self.controller.currentPage is SignUpPage:
                        self.token_label1.config(text=&#34;Your unique token is &#34; + str(self.controller.messageChannel.responses[0][&#34;value&#34;]))
                        self.token_label1.grid(row=2, column=0, columnspan=2, pady=(20, 50), sticky=&#34;w&#34;)
                # an error has occurred
                case &#34;1_errorHasOccured&#34;:
                        self.token_label1.config(text=&#34;error has occured, try again&#34;)
                        self.token_label1.grid(row=2, column=0, columnspan=2, pady=(20, 50), sticky=&#34;w&#34;)  
            
            # pop the response from the queue of responses
            self.controller.messageChannel.responses.pop(0)
      
        else:
            # Otherwise check again after one second
            schedule_check(self, t, self.check_if_signUp_done.__name__)


    def getNikNameEntry(self):
        &#34;&#34;&#34;get the text in the &#39;insert token&#39; entry

        Returns:
            str: token, unique ID of the user
        &#34;&#34;&#34;
        return self.nikName_entry.get()
    

    def exitTheGame(self):
        &#34;&#34;&#34;upon clicking the &#39;exit&#39; button, handle exiting the game gracefully by sending a message
            to the server
        &#34;&#34;&#34;
        self.controller.messageChannel.setRequest(&#34;exit&#34;, &#34;a&#34;)


class MainPage(tk.Frame):
    &#34;&#34;&#34;Page for main menu of the app
    &#34;&#34;&#34;
    def __init__(self, master, controller):
        &#34;&#34;&#34;constructor for SignUpPage

        Args:
            parent (tk.Frame): a frame that inherits from the app root
            controller (AppRoot): the controller of the app
        &#34;&#34;&#34;
        tk.Frame.__init__(self, master)
        
        self.master = master
        self.controller = controller
        self.configure(bg=&#34;#f0f0f0&#34;)
        self.create_widgets() # call the function that create the graphical elements


    def create_widgets(self):
        &#34;&#34;&#34;create the graphical elements and define their properties
        &#34;&#34;&#34;
        # Headline label
        headline_label = tk.Label(self, text=&#34;Game Center&#34;, font=(&#34;Verdana&#34;, 24, &#34;bold&#34;), bg=&#34;#f0f0f0&#34;)
        headline_label.pack(pady=10)

        # Buttons frame
        self.buttons_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
        self.buttons_frame.pack()

        # New Game button
        self.new_game_button = tk.Button(self.buttons_frame, text=&#34;New Game&#34;, width=15, font=(&#34;Verdana&#34;, 12), bg=&#34;#4CAF50&#34;, fg=&#34;white&#34;, relief=tk.FLAT, command=self.new_game)
        self.new_game_button.grid(row=0, column=0, padx=10)

        # Join a Game button
        self.join_game_button = tk.Button(self.buttons_frame, text=&#34;Join a Game&#34;, width=15, font=(&#34;Arial&#34;, 12), bg=&#34;#FFC107&#34;, fg=&#34;white&#34;, relief=tk.FLAT, command=self.join_game)
        self.join_game_button.grid(row=0, column=1, padx=10)

        # View Leadership Games button
        view_games_button = tk.Button(self.buttons_frame, text=&#34;View Leadership Games&#34;, width=20, font=(&#34;Arial&#34;, 12), bg=&#34;#2196F3&#34;, fg=&#34;white&#34;, relief=tk.FLAT, command=lambda: self.controller.show_page(StatisticsPage))
        view_games_button.grid(row=0, column=2, padx=10)

        # Games list frame (initially hidden)
        self.games_list_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
        self.games_list_frame.pack()

        # Listbox for games
        self.games_listbox = tk.Listbox(self.games_list_frame, width=50, height=10, font=(&#34;Arial&#34;, 12), bg=&#34;white&#34;, selectbackground=&#34;#FFC107&#34;)
        self.games_listbox.pack(side=&#34;left&#34;, fill=&#34;y&#34;, padx=5, pady=5)
        
        # Bind callback function to listbox selection event
        self.games_listbox.bind(&#34;&lt;Double-Button-1&gt;&#34;, self.on_game_select)
        
        # Scrollbar for listbox
        scrollbar = tk.Scrollbar(self.games_list_frame, orient=&#34;vertical&#34;, command=self.games_listbox.yview)
        scrollbar.pack(side=&#34;right&#34;, fill=&#34;y&#34;)

        # Configure listbox to use scrollbar
        self.games_listbox.config(yscrollcommand=scrollbar.set)


        self.activeGames_initialized = []
        self.activeGames_occuring = []

        # Text entry for number of players (initially hidden)
        self.players_entry_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
        self.players_entry_label = tk.Label(self.players_entry_frame, text=&#34;Number of Players:&#34;, font=(&#34;Verdana&#34;, 12), bg=&#34;#f0f0f0&#34;)
        self.players_entry_label.pack(side=&#34;left&#34;, padx=5, pady=5)
        self.players_entry = tk.Entry(self.players_entry_frame, font=(&#34;Arial&#34;, 12), width=10, justify=&#39;center&#39;)
        self.players_entry.pack(side=&#34;left&#34;, padx=5, pady=5)
        self.players_entry_frame.pack()

        # Radio buttons for player type (initially hidden)
        self.player_type_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
        self.player_type_label = tk.Label(self.player_type_frame, text=&#34;Player Type:&#34;, font=(&#34;Arial&#34;, 12), bg=&#34;#f0f0f0&#34;)
        self.player_type_label.pack(side=&#34;left&#34;, padx=5, pady=5)

        self.player_type_var = tk.StringVar(value=&#34;active_player&#34;)
        self.player_last_type = &#34;active_player&#34; # used to verify that the user changed the radio button selection
                                                # and not just clicked on the same button

        style = ttk.Style()
        style.configure(&#34;TRadiobutton&#34;, background=&#34;#f0f0f0&#34;, font=(&#34;Arial&#34;, 12))

        self.active_player_radio = ttk.Radiobutton(self.player_type_frame, text=&#34;Active Player&#34;, variable=self.player_type_var, value=&#34;active_player&#34;, command=self.handle_radio_click)
        self.active_player_radio.pack(side=&#34;left&#34;, padx=5, pady=5)

        self.spectator_radio = ttk.Radiobutton(self.player_type_frame, text=&#34;Spectator&#34;, variable=self.player_type_var, value=&#34;spectator&#34;, command=self.handle_radio_click)
        self.spectator_radio.pack(side=&#34;left&#34;, padx=5, pady=5)

        self.player_type_frame.pack()

        # Logout and Exit buttons frame
        logout_exit_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
        logout_exit_frame.pack(side=&#34;bottom&#34;, fill=&#34;x&#34;)

        # Logout button
        logout_button = tk.Button(logout_exit_frame, text=&#34;Logout&#34;, width=10, font=(&#34;Arial&#34;, 12), bg=&#34;#FFC107&#34;, fg=&#34;white&#34;, relief=tk.FLAT, command=self.logout)
        logout_button.pack(side=&#34;left&#34;, padx=10, pady=10)

        # Exit button
        exit_button = tk.Button(logout_exit_frame, text=&#34;Exit&#34;, width=10, font=(&#34;Arial&#34;, 12), bg=&#34;#F44336&#34;, fg=&#34;white&#34;, relief=tk.FLAT, command=self.exit_app)
        exit_button.pack(side=&#34;right&#34;, padx=10, pady=10)

        # Hide the games list frame, players entry, and player type radio buttons initially
        self.games_list_frame.pack_forget()
        self.players_entry_frame.pack_forget()
        self.player_type_frame.pack_forget()

    
    def new_game(self):
        &#34;&#34;&#34;the user clicked on the &#39;New Game&#39; button
        &#34;&#34;&#34;
        self.games_list_frame.pack_forget()  # hide the listbox
        self.player_type_frame.pack_forget() # hide the player type frame
        if (self.new_game_button.cget(&#39;text&#39;) == &#34;New Game&#34;):
            self.players_entry_frame.pack()
            self.new_game_button.config(text=&#34;start!&#34;) # change the text of the button to &#39;start&#39;

        # the text of the button is &#39;start&#39;, which means that a text entry for number of players is already vidsible
        else:
            players_entry = self.players_entry.get()
            if (players_entry == &#34;&#34;  or  int(players_entry) &lt; 2  or  int(players_entry) &gt; 8):
                messagebox.showinfo(&#34;message&#34;, &#34;please insert a valid number of players (2-8 allowed)&#34;)
            else:
                self.controller.messageChannel.setRequest(&#34;newGame&#34;, int(players_entry)) # set a request for a new game

                t = threading.Thread(target=self.newGame_helper)
                t.start()
                # check periodically for a response from the server and handle a response in &#39;check_if_newGame_done&#39;
                schedule_check(self, t, self.check_if_newGame_done.__name__)


    def newGame_helper(self):
        &#34;&#34;&#34;check if a response from the server about the auth request has arrived.
            At first we check if the response is None i.e. no response has arrived, and then we verify
            that the response is what we expected to, i.e. &#34;response&#34; == &#34;2_newRegisteredGame&#34;, else we continue looping.
        &#34;&#34;&#34;
        while (self.controller.messageChannel.responses == []  or  
               self.controller.messageChannel.responses[0][&#34;response&#34;][0] != &#34;2&#34;):
            pass


    def check_if_newGame_done(self, t):
        &#34;&#34;&#34;if the thread &#39;t&#39; is dead then it means a response from the server about the auth request has arrived,
            the function handle that response
        Args:
            t (Thread): the thread that is in charge of checking if a newGame response has arrived
        &#34;&#34;&#34;
        if not t.is_alive():
            match self.controller.messageChannel.responses[0][&#34;response&#34;]: # examine the response headline
                # the request for a new game has granted
                case &#34;2_newRegisteredGame&#34;:
                    game = self.controller.messageChannel.responses[0][&#34;value&#34;] # should be a list [ game_ID, numOfPlayers ]
                    if self.controller.currentPage is MainPage:
                        self.controller.show_page(GamePage, game[1], game[0]) # move the the game page with two parameters: game_ID, num of players
                        # append a message to the player to the mesage queue
                        self.controller.currentPageInstance.message_buffer.append(f&#34;## waiting for {game[1]-1} more players to join and then we start!&#34;)
                case &#34;2_errorHasOccured&#34;:
                    messagebox.showinfo(&#34;message&#34;, &#34;an error has occured during a try to initiate a new game&#34;)
            # pop the handled response from the responses queue
            self.controller.messageChannel.responses.pop(0)

        else:
            # Otherwise check again after one second
            schedule_check(self, t, self.check_if_newGame_done.__name__)

    def join_game(self):
        &#34;&#34;&#34;a function to handle click on the &#39;join Game&#39; button
        &#34;&#34;&#34;
        # if the user clicked on the button of &#39;join&#39; after the &#39;New Game&#39; button was clicked once, retrieve the original text to the &#39;new game&#39; button
        self.new_game_button.config(text=&#34;New Game&#34;) 
        self.players_entry_frame.pack_forget()  # hide the &#39;number of players&#39; text entry that associated with a &#39;new game&#39; and not with a &#39;join game&#39; click
        self.games_list_frame.pack()            # show the list of open games
        
        self.join_game_button[&#34;state&#34;] = &#34;disabled&#34; # disable button until a response arrives
        
        self.controller.messageChannel.setRequest(&#34;fetchActiveGames&#34;, &#34;a&#34;) # send a request to fetch all active games from the server


        t = threading.Thread(target=self.fetchActiveGames_helper)
        t.start()
        # check periodically for a response from the server and handle a response in &#39;check_if_newGame_done&#39;
        schedule_check(self, t, self.check_if_fetchActiveGames_done.__name__)


    def fetchActiveGames_helper(self):
        &#34;&#34;&#34;check if a response from the server about &#39;fetching the games&#39; request has arrived.
            At first we check if the response is None i.e. no response has arrived, and then we verify
            that the response is what we expected to, i.e. &#34;response&#34; == &#34;3_allActiveGames&#34;, else we continue looping.
        &#34;&#34;&#34;
        while (self.controller.messageChannel.responses == []  or  
               self.controller.messageChannel.responses[0][&#34;response&#34;][0] != &#34;3&#34;):
            pass


    def check_if_fetchActiveGames_done(self, t):
        &#34;&#34;&#34;if the thread &#39;t&#39; is dead then it means a response from the server about the auth request has arrived,
            the function handle that response
        Args:
            t (Thread): the thread that is in charge of checking if a fetchActiveGames response has arrived
        &#34;&#34;&#34;
        if not t.is_alive():
            self.games_listbox.delete(0,&#34;end&#34;) # clear the list of games before populating it
            self.activeGames_initialized = []
            self.activeGames_occuring = []

            games = self.controller.messageChannel.responses[0][&#34;value&#34;]
            for key, game in games.items():
                # we get the following format: key = gameID, game = ({Game as dict}, number of active participants, number of passive participants - spectators)
                if (game[0][&#34;game_state&#34;] == &#34;INITIALIZED&#34;):
                    self.activeGames_initialized.append(game)
                elif (game[0][&#34;game_state&#34;] == &#34;STARTED&#34;):
                    self.activeGames_occuring.append(game)

            # building the list of games for displaying it to the user
            for index, game in enumerate(self.activeGames_initialized):
                strForDisplay = f&#34;Game {index+1} (opened for &#34; + str(game[0][&#34;num_of_players&#34;]) + &#34; players, waiting for &#34; + str(game[0][&#34;num_of_players&#34;]-game[1]) + &#34; more, &#34; + str(game[2]) + &#34; spectators&#34; + &#34;)&#34;
                self.games_listbox.insert(&#34;end&#34;, strForDisplay)
            
            self.player_type_frame.pack()               # display two option for the user: spectator or player
            self.join_game_button[&#34;state&#34;] = &#34;normal&#34;   # make the button clickable

            # pop the resposne from the queue of responses
            self.controller.messageChannel.responses.pop(0)
      
        else:
            # Otherwise check again after one second
            schedule_check(self, t, self.check_if_fetchActiveGames_done.__name__)


    def handle_radio_click(self):
        &#34;&#34;&#34;handle clicking on one of the radio buttons: spectator or player
        &#34;&#34;&#34;
        player_type = self.player_type_var.get()
        print(f&#34;Selected player type: {player_type}&#34;)
        if (player_type != self.player_last_type): # handke click only if it is differnet from the last click (because the user can click on the same button more than once)
            if player_type == &#34;active_player&#34; and self.activeGames_occuring != []:
                # delete the items repreenting occurring games, whom the player can&#39;t join
                self.games_listbox.delete(len(self.activeGames_initialized),len(self.activeGames_initialized)+len(self.activeGames_occuring)-1)
            elif player_type == &#34;spectator&#34;:
                # add the occurring games, because as a spectator the user can join either a game that has not yet started or an already started gamnes
                for index, game in enumerate(self.activeGames_occuring):
                    strForDisplay = f&#34;Game {len(self.activeGames_initialized)+index+1} (opened for &#34; + str(game[0][&#34;num_of_players&#34;]) + &#34; players, waiting for &#34; + str(game[0][&#34;num_of_players&#34;]-game[1]) + &#34; more, &#34; + str(game[2]) + &#34; spectators&#34; + &#34;)&#34;
                    self.games_listbox.insert(&#34;end&#34;, strForDisplay)

        self.player_last_type = player_type


    def on_game_select(self, event):
        &#34;&#34;&#34;handle clikcing on a game entry in the box list for joining

        Args:
            event: which event happened (defined for double-click only)
        &#34;&#34;&#34;
        selected_index = self.games_listbox.curselection()[0]

        # the user is a spectator in an occurring game
        if (selected_index &gt;= len(self.activeGames_initialized)): 
            selectedGame = self.activeGames_occuring[selected_index-len(self.activeGames_initialized)][0]
            self.controller.show_page(GamePage, selectedGame[&#34;num_of_players&#34;], selectedGame[&#34;game_ID&#34;], selectedGame[&#34;board&#34;], True)

        # the user is either an active player or a spectator in a game that has not yet started
        else:
            selectedGame = self.activeGames_initialized[selected_index][0]
            if self.player_type_var.get() == &#34;spectator&#34;:
                self.controller.show_page(GamePage, selectedGame[&#34;num_of_players&#34;], selectedGame[&#34;game_ID&#34;], &#34;&#34;, True)
            else:
                self.controller.show_page(GamePage, selectedGame[&#34;num_of_players&#34;], selectedGame[&#34;game_ID&#34;])
             

        # send a message to the server that a new player has now joined the game
        if self.player_type_var.get() == &#34;active_player&#34;:
            self.controller.messageChannel.setRequest(&#34;newJoined&#34;, (&#34;player&#34;, selectedGame[&#34;game_ID&#34;]))
        
        # self.player_type_var.get() == &#34;spectator&#34;
        else:
            self.controller.currentPageInstance.spectator_label.pack()
            self.controller.messageChannel.setRequest(&#34;newJoined&#34;, (&#34;spectator&#34;, selectedGame[&#34;game_ID&#34;]))


    def logout(self):
        &#34;&#34;&#34;handle clicking in the &#39;logout&#39; button
        &#34;&#34;&#34;
        self.controller.messageChannel.setRequest(&#34;logout&#34;, &#34;a&#34;) # send a request to log out
        self.controller.show_page(AuthPageToken)                 # move back to the authentication page

    def exit_app(self):
        &#34;&#34;&#34;upon clicking the &#39;exit&#39; button, handle exiting the game gracefully by sending a message
            to the server
        &#34;&#34;&#34;
        self.controller.messageChannel.setRequest(&#34;exit&#34;, &#34;a&#34;)


class StatisticsPage(tk.Frame):
    &#34;&#34;&#34;page for displaying statistics about the games and users
    &#34;&#34;&#34;
    def __init__(self, master, controller):
        &#34;&#34;&#34;constructor for SignUpPage

        Args:
            parent (tk.Frame): a frame that inherits from the app root
            controller (AppRoot): the controller of the app
        &#34;&#34;&#34;
        tk.Frame.__init__(self, master)

        self.master = master
        self.controller = controller
        
        self.games = []
        self.users = []

        self.create_widgets() # call the function that create the graphical elements
        
        self.fetchInfo() # prepare the information for display


    def create_widgets(self):
        &#34;&#34;&#34;create the graphical elements and define their properties
        &#34;&#34;&#34;
        # create headline
        self.headline_label = ttk.Label(self, text=&#34;Game Statistics&#34;, font=(&#34;Helvetica&#34;, 30, &#34;bold&#34;), foreground=&#34;blue&#34;)
        self.headline_label.pack(pady=10)

        # create tabs (games and users)
        self.tabControl = ttk.Notebook(self)

        self.tab1 = ttk.Frame(self.tabControl)
        self.tabControl.add(self.tab1, text=&#34;Games&#34;)

        self.tab2 = ttk.Frame(self.tabControl)
        self.tabControl.add(self.tab2, text=&#34;Users&#34;)

        self.tabControl.pack(expand=1, fill=&#34;x&#34;)
        self.tabControl.bind(&#34;&lt;&lt;NotebookTabChanged&gt;&gt;&#34;, self.tab_changed)

        # create tables for games and users
        self.table1_frame = ttk.Frame(self)
        self.table1_frame.pack(fill=&#34;both&#34;, expand=1, padx=20, pady=10)

        self.table2_frame = ttk.Frame(self)
        self.table2_frame.pack(fill=&#34;both&#34;, expand=1, padx=20, pady=10)

        self.treeViewGames = ttk.Treeview(self.table1_frame, columns=(&#34;index&#34;, &#34;date&#34;, &#34;duration&#34;, &#34;num_of_players&#34;, &#34;status&#34;, &#34;winner&#34;), show=&#34;headings&#34;)
        self.treeViewGames.heading(&#34;index&#34;, text=&#34;#&#34;)
        self.treeViewGames.heading(&#34;date&#34;, text=&#34;date&#34;)
        self.treeViewGames.heading(&#34;duration&#34;, text=&#34;duration&#34;)
        self.treeViewGames.heading(&#34;num_of_players&#34;, text=&#34;number of players&#34;)
        self.treeViewGames.heading(&#34;status&#34;, text=&#34;status&#34;)
        self.treeViewGames.heading(&#34;winner&#34;, text=&#34;winner&#34;)

        self.treeViewGames.column(&#34;index&#34;, width=50, anchor=&#34;center&#34;)
        self.treeViewGames.column(&#34;date&#34;, width=150, anchor=&#34;center&#34;)
        self.treeViewGames.column(&#34;duration&#34;, width=50, anchor=&#34;center&#34;)
        self.treeViewGames.column(&#34;num_of_players&#34;, width=100, anchor=&#34;center&#34;)
        self.treeViewGames.column(&#34;status&#34;, width=50, anchor=&#34;center&#34;)
        self.treeViewGames.column(&#34;winner&#34;, width=150, anchor=&#34;center&#34;)

        self.treeViewUsers = ttk.Treeview(self.table2_frame, columns=(&#34;user_name&#34;, &#34;number_of_games&#34;, &#34;number_of_winnings&#34;, &#34;number_of_loses&#34;, &#34;number_of_draws&#34;), show=&#34;headings&#34;)
        self.treeViewUsers.heading(&#34;user_name&#34;, text=&#34;user name&#34;)
        self.treeViewUsers.heading(&#34;number_of_games&#34;, text=&#34;number of games&#34;)
        self.treeViewUsers.heading(&#34;number_of_winnings&#34;, text=&#34;won&#34;)
        self.treeViewUsers.heading(&#34;number_of_loses&#34;, text=&#34;lost&#34;)
        self.treeViewUsers.heading(&#34;number_of_draws&#34;, text=&#34;draw&#34;)

        self.treeViewUsers.column(&#34;user_name&#34;, width=150, anchor=&#34;center&#34;)
        self.treeViewUsers.column(&#34;number_of_games&#34;, width=100, anchor=&#34;center&#34;)
        self.treeViewUsers.column(&#34;number_of_winnings&#34;, width=100, anchor=&#34;center&#34;)
        self.treeViewUsers.column(&#34;number_of_loses&#34;, width=100, anchor=&#34;center&#34;)
        self.treeViewUsers.column(&#34;number_of_draws&#34;, width=100, anchor=&#34;center&#34;)

        self.treeViewGames.pack(side=&#34;left&#34;, fill=&#34;both&#34;, expand=True)
        self.treeViewUsers.pack(side=&#34;left&#34;, fill=&#34;both&#34;, expand=True)

        # create scroll bar for scrooling the information in the tables
        self.scrollbar1 = ttk.Scrollbar(self.table1_frame, orient=&#34;vertical&#34;, command=self.treeViewGames.yview)
        self.scrollbar1.pack(side=&#34;right&#34;, fill=&#34;y&#34;)
        self.treeViewGames.configure(yscroll=self.scrollbar1.set)

        self.scrollbar2 = ttk.Scrollbar(self.table2_frame, orient=&#34;vertical&#34;, command=self.treeViewUsers.yview)
        self.scrollbar2.pack(side=&#34;right&#34;, fill=&#34;y&#34;)
        self.treeViewUsers.configure(yscroll=self.scrollbar2.set)

        # hide the table of users at initialization
        self.table2_frame.pack_forget()

        # buttons frame
        self.button_frame = ttk.Frame(self)
        self.button_frame.pack(pady=10)
        
        # button for exiting the application
        self.exit_button = ttk.Button(self.button_frame, text=&#34;Exit&#34;, command=self.exitApp, width=10)
        self.exit_button.pack(side=&#34;left&#34;, padx=10)

        # button for getting out of the game
        self.back_button = ttk.Button(self.button_frame, text=&#34;Back to Main&#34;, command=lambda: self.controller.show_page(MainPage), width=15)
        self.back_button.pack(side=&#34;left&#34;, padx=10)
        

        # Initialize style
        s = ttk.Style()

        # Create style for the first frame
        s.configure(&#39;TFrame&#39;, background=&#39;#f0f0f0&#39;)
        
        self.configure(bg=&#34;#f0f0f0&#34;)
        self.headline_label.configure(background=&#34;#f0f0f0&#34;)

        
    def fetchInfo(self):
        &#34;&#34;&#34;send a request to the server for games history and users statistics
        &#34;&#34;&#34;
        self.controller.messageChannel.setRequest(&#34;fetchGamesHistory&#34;, &#34;&#34;)
        
        t = threading.Thread(target=self.gamesHistory_helper)
        t.start()
        # check periodically for a response from the server and handle a response in &#39;check_if_signUp_done&#39;
        schedule_check(self, t, self.check_if_gamesHistory_done.__name__)


    def gamesHistory_helper(self):
        &#34;&#34;&#34;check if a response from the server about the &#39;fetchGamesHistory&#39; request has arrived.
            At first we check if the response is None i.e. no response has arrived, and then we verify
            that the response is what we expected to, i.e. &#34;response&#34; == &#34;16_gamesHistory&#34;, else we continue looping.
        &#34;&#34;&#34;
        while (self.controller.messageChannel.responses == []  or
               self.controller.messageChannel.responses[0][&#34;response&#34;][0:2] != &#34;16&#34;):
            pass

    def check_if_gamesHistory_done(self, t):
        &#34;&#34;&#34;if the thread &#39;t&#39; is dead then it means a response from the server about the &#39;gamesHistory&#39; request has arrived,
            the function handle that response
        Args:
            t (Thread): the thread that is in charge of the gamesHistory response
        &#34;&#34;&#34;
        if not t.is_alive():
            games = self.controller.messageChannel.responses[0][&#34;value&#34;] # should be a list of lists: [... [game_ID: str, game: dict] ...]
            if self.controller.currentPage is StatisticsPage:
                self.games = games
                if games == []:
                    messagebox.showinfo(&#34;message&#34;, &#34;it seems like the server has no information about games statistics&#34;)
                self.populate_table(1) # populate the table of games with history of recent games
            
            # pop the handled response fron the queue of responses
            self.controller.messageChannel.responses.pop(0)
            # only after fetching history of games we fetch the statistics of users
            self.controller.messageChannel.setRequest(&#34;fetchUsersStats&#34;, &#34;&#34;)
        
            t = threading.Thread(target=self.usersStats_helper)
            t.start()
            # check periodically for a response from the server and handle a response in &#39;check_if_usersStat_done&#39;
            schedule_check(self, t, self.check_if_usersStats_done.__name__)

        else:
            # Otherwise check again after one second
            schedule_check(self, t, self.check_if_gamesHistory_done.__name__)
    
    def usersStats_helper(self):
        &#34;&#34;&#34;check if a response from the server about the &#39;fetchUsersStats&#39; request has arrived.
            At first we check if the response is None i.e. no response has arrived, and then we verify
            that the response is what we expected to, i.e. &#34;response&#34; == &#34;17_usersStats&#34;, else we continue looping.
        &#34;&#34;&#34;
        while (self.controller.messageChannel.responses == []  or
               self.controller.messageChannel.responses[0][&#34;response&#34;][0:2] != &#34;17&#34;):
            pass            

    def check_if_usersStats_done(self, t):
        &#34;&#34;&#34;if the thread &#39;t&#39; is dead then it means a response from the server about the &#39;userStats&#39; request has arrived,
            the function handle that response
        Args:
            t (Thread): the thread that is in charge of checking if &#39;userStats&#39; response has arrived
        &#34;&#34;&#34;
        if not t.is_alive():
            usersStats = self.controller.messageChannel.responses[0][&#34;value&#34;] # should be a list of items: (nik name: str, user: dict)
            if self.controller.currentPage is StatisticsPage:
                self.users = usersStats
                if usersStats == []:
                    messagebox.showinfo(&#34;message&#34;, &#34;it seems like the server has no information about user statistics&#34;)
                self.populate_table(2) # populate table of users

            # pop the handled response from the queue of responses
            self.controller.messageChannel.responses.pop(0)
        else:
            # Otherwise check again after one second
            schedule_check(self, t, self.check_if_usersStats_done.__name__)


    def populate_table(self, table: int):
        &#34;&#34;&#34;populate the table whose index is given as parameter &#39;table&#39;

        Args:
            table (int): 1 for the table of games, 2 for the table of users
        &#34;&#34;&#34;
        # Populate table with data based on the selected tab index
        if table == 1: # games
            for i, game in enumerate(self.games):
                # construct a date format
                date = datetime.datetime.fromisoformat(game[1][&#34;creation_date&#34;]).strftime(&#34;%d/%m/%Y&#34;)
                # duration in seconds
                duration_micro = str(datetime.timedelta(seconds = game[1][&#34;duration&#34;]))
                index = duration_micro.rfind(&#34;.&#34;)
                # throw the fragment of second after the dot
                duration = duration_micro if index == -1 else duration_micro[:index]
                if game[1][&#34;game_state&#34;] == &#39;WON&#39;:    
                    status = &#34;victory&#34;
                    winner = game[1][&#34;winner_name&#34;]
                else:
                    status = &#34;draw&#34;
                    winner = &#34;-&#34;
            
                self.treeViewGames.insert(&#34;&#34;, &#34;end&#34;, values=(str(i+1), date, duration, game[1][&#34;num_of_players&#34;], status, winner))
        else: # users
            self.table = self.treeViewUsers
            self.table.pack(side=&#34;left&#34;, fill=&#34;both&#34;, expand=True)
            for user in self.users:
                num_games = user[1][&#34;games_participated&#34;]
                victory = user[1][&#34;games_won&#34;]
                draw = user[1][&#34;games_tie&#34;]
                loses = num_games - victory - draw
                self.treeViewUsers.insert(&#34;&#34;, &#34;end&#34;, values=(user[0], num_games, victory, loses, draw))


    def tab_changed(self, event):
        &#34;&#34;&#34;handle event of changing tab in the listbox

        Args:
            event: click on one of the tabs
        &#34;&#34;&#34;
        # Get the index of the currently selected tab
        tab_index = self.tabControl.index(self.tabControl.select())

        if (tab_index == 0): # click on &#39;games&#39; tab
            # Update the content of the table based on the selected tab
            self.button_frame.pack_forget()
            self.table1_frame.pack(fill=&#34;both&#34;, expand=1, padx=20, pady=10)
            self.table2_frame.pack_forget()
            self.button_frame.pack(pady=10)
            
        else: # tab_changed = 1, click on &#39;users&#39; tab
            self.button_frame.pack_forget()
            self.table2_frame.pack(fill=&#34;both&#34;, expand=1, padx=20, pady=10)
            self.table1_frame.pack_forget()
            self.button_frame.pack(pady=10)


    def exitApp(self):
        &#34;&#34;&#34;upon clicking the &#39;exit&#39; button, handle exiting the game gracefully by sending a message
            to the server
        &#34;&#34;&#34;
        self.controller.messageChannel.setRequest(&#34;exit&#34;, &#34;a&#34;)





class GamePage(tk.Frame):
    &#34;&#34;&#34;page for displaying the game elements and handle events about it
    &#34;&#34;&#34;
    def __init__(self, parent, controller, num_of_players : int,  game_ID: str = &#34;&#34;, board = &#34;&#34;, isSpectator = False):
        &#34;&#34;&#34;construct the &#39;GamePage&#39; object, initialize board, timer and messages

        Args:
            parent (tk.Frame): a frame that inherits from the app root
            controller (AppRoot): the controller of the app
            num_of_players (int): number of players (for building the board with the right size)
            game_ID (str, optional): ID of the game. Defaults to &#34;&#34;.
            board (str, optional): game grid. Defaults to &#34;&#34;.
            isSpectator (bool, optional): a flag to know if the user chose to be a spectator or a player. Defaults to False.
        &#34;&#34;&#34;
        tk.Frame.__init__(self, parent)
        self.master = parent
        self.controller = controller
        self.game_ID = game_ID
        self.size = num_of_players + 1  # size of board in x and y axis
        self.configure(bg=&#34;#f0f0f0&#34;)    # Set background color
        
        # if a spectator has joined in the middle of a game, we need to initialize his board
        if board != &#34;&#34;:
            self.board = board
        else:
            self.board = [[&#39; &#39; for _ in range(self.size)] for _ in range(self.size)]

        
        self.symbol_player = &#39;no&#39;
        self.isSpectator = isSpectator

        self.isStarted = False # flag primarly for staring the timer
        self.yourTurn = False  # flag to know if it&#39;s the turn of this player

        self.message_buffer = []

        self.game_result = &#34;waiting&#34; # game status
        self.secondsForTimeout = 30  # put here no more than 59

        self.create_widgets()
        self.update_timer_and_messages()

    def create_widgets(self):
        &#34;&#34;&#34;create the graphical elements and define their properties
        &#34;&#34;&#34;
        # Frame for the grid
        self.grid_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
        self.grid_frame.grid(row=0, column=0, padx=10, pady=10, sticky=&#34;nsew&#34;)

        self.buttons = [[None for _ in range(self.size)] for _ in range(self.size)]
        for i in range(self.size):
            self.grid_frame.grid_columnconfigure(i, weight=1)  # Expand columns equally
            self.grid_frame.grid_rowconfigure(i, weight=1)     # Expand rows equally
            for j in range(self.size):
                self.buttons[i][j] = tk.Button(self.grid_frame, text=self.board[i][j], font=(&#39;Arial&#39;, 16, &#39;bold&#39;), width=3, height=1,
                                                command=lambda i=i, j=j: self.on_button_click(i, j), bg=&#34;#ffffff&#34;, fg=&#34;#000000&#34;, bd=1, relief=&#34;solid&#34;)
                self.buttons[i][j].grid(row=i, column=j, sticky=&#34;nsew&#34;)
                
        
        # Frame for buttons and timer
        self.control_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
        self.control_frame.grid(row=0, column=1, padx=0, pady=0, sticky=&#34;n&#34;)
        self.control_frame.grid_propagate(False)

        self.buttons_frame = tk.Frame(self.control_frame, bg=&#34;#f0f0f0&#34;)
        self.buttons_frame.pack(side=&#34;top&#34;, fill=&#34;y&#34;, padx=0, pady=0)

        self.quit_button = tk.Button(self.buttons_frame, text=&#34;Quit Game&#34;, command=self.quit_game, font=(&#39;Arial&#39;, 12), bg=&#34;#d32f2f&#34;, fg=&#34;#ffffff&#34;, bd=1, relief=&#34;solid&#34;)
        self.quit_button.grid(row=0, column=0, pady=5, padx=5, sticky=&#34;ew&#34;)

        self.exit_button = tk.Button(self.buttons_frame, text=&#34;Exit&#34;, command=self.exit_app, font=(&#39;Arial&#39;, 12), bg=&#34;#303f9f&#34;, fg=&#34;#ffffff&#34;, bd=1, relief=&#34;solid&#34;)
        self.exit_button.grid(row=1, column=0, pady=5, padx=5, sticky=&#34;ew&#34;)

        self.timer_label = tk.Label(self.buttons_frame, text=&#34;&#34;, font=(&#39;Arial&#39;, 12), bg=&#34;#f0f0f0&#34;)
        self.timer_label.grid(row=2, column=0, pady=5, padx=5, sticky=&#34;ew&#34;)

        self.catchSpace_label = tk.Label(self.buttons_frame, text=&#34;&#34;, font=(&#39;Arial&#39;, 12), bg=&#34;#f0f0f0&#34;)
        self.catchSpace_label.grid(row=3, column=0, pady=5, padx=5, sticky=&#34;ew&#34;)

        self.game_turn_label = tk.Label(self.control_frame, text=&#34;you&#39;ll  wait&#34;, pady=10, padx=20, font=(&#39;Arial&#39;, 20), bg=&#34;#404040&#34;, fg=&#34;#ffffff&#34;)
        self.game_turn_label.pack(side=&#34;bottom&#34;, fill=&#34;y&#34;, padx=0, pady=5)

        self.spectator_label = tk.Label(self.control_frame, text=&#34;spectator&#34;, pady=10, padx=20, font=(&#39;Arial&#39;, 20), bg=&#34;#cc00cc&#34;, fg=&#34;#ffffff&#34;)
        self.spectator_label.pack(side=&#34;bottom&#34;, fill=&#34;y&#34;, padx=0, pady=5)
        self.spectator_label.pack_forget()

        # Frame for messages with scrollable area
        self.message_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
        self.message_frame.grid(row=1, column=0, columnspan=2, padx=10, pady=10, sticky=&#34;nsew&#34;)

        self.message_scrollbar = tk.Scrollbar(self.message_frame)
        self.message_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        self.message_text = tk.Text(self.message_frame, height=5, width=50, font=(&#39;Arial&#39;, 12), bg=&#34;#ffffff&#34;, fg=&#34;#000000&#34;, bd=1, relief=&#34;solid&#34;)
        self.message_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.message_text.config(state=tk.DISABLED)  # Make text area read-only

        self.message_scrollbar.config(command=self.message_text.yview)
        self.message_text.config(yscrollcommand=self.message_scrollbar.set)

        # Configure row and column weights to make the message frame stretchable
        self.grid_rowconfigure(0, weight=1)
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=1)
        self.grid_columnconfigure(1, weight=1)
    
    def assignSymbol(self, symbol: int) -&gt; str:
        &#34;&#34;&#34;assign the symmbol fir this player and return it

        Args:
            symbol (int): the int representation of the symbol

        Returns:
            str: the symbol as string (&#39;O&#39;, &#39;X&#39;, etc.)
        &#34;&#34;&#34;
        self.symbol_player = symbol
        return symbol

    def restartTimer(self):
        &#34;&#34;&#34;restart the timer by updating the start_time variable to the current time
        &#34;&#34;&#34;
        self.start_time = time.time()

    def on_button_click(self, row: int, col: int):
        &#34;&#34;&#34;handle the event of clicking of the board

        Args:
            row (int): row of the button clicked
            col (int): column of the button clicked
        &#34;&#34;&#34;
        if self.yourTurn  and  self.board[row][col] == &#39; &#39;:
                self.buttons[row][col][&#39;text&#39;] = self.symbol_player
                self.yourTurn = False # not your turn anymore

                # send a request about a button click on the boarf of the game
                self.controller.messageChannel.setRequest(&#34;aMove&#34;, ((row, col, self.symbol_player), self.game_ID))

    def updateBoardAndButton(self, row: int, col: int, symbol: str):
        &#34;&#34;&#34;update the board of game for display

        Args:
            row (int): row of button to update
            col (int): column of button to update
            symbol (str): string representation of the symbol of this player
        &#34;&#34;&#34;
        self.buttons[row][col][&#39;text&#39;] = symbol

    def update_timer_and_messages(self):
        &#34;&#34;&#34;update the timer the the board of messages
        &#34;&#34;&#34;
        if (len(self.message_buffer) &gt; 0):
            self.add_message(self.message_buffer.pop(0)) # add the message that just now poped out from the queue of messages
            
            
        if (self.isStarted):
            # calculate the new time in the timer and display it with some format
            elapsed_time = int(time.time() - self.start_time)
            minutes = elapsed_time // 60
            seconds = elapsed_time % 60
            self.timer_label.config(text=f&#34;Time: {minutes:02d}:{seconds:02d}&#34;)
        
            # handle timeout
            if (seconds == self.secondsForTimeout  and  self.yourTurn == True):
                self.yourTurn = False
                self.controller.messageChannel.setRequest(&#34;timeout&#34;, self.game_ID)
        
        # call again after 1 second
        self.timer_label.after(1000, self.update_timer_and_messages)

    def add_message(self, message: str):
        &#34;&#34;&#34;add a message to the message box

        Args:
            message (str): string of the message to add
        &#34;&#34;&#34;
        self.message_text.config(state=tk.NORMAL)  # Enable editing temporarily
        self.message_text.insert(tk.END, message + &#39;\n\n&#39;)
        self.message_text.config(state=tk.DISABLED)  # Make read-only again
        self.message_text.see(tk.END)  # Scroll to the bottom

    def quit_game(self):
        &#34;&#34;&#34;quit from the game, and notify other players if the game is not over
        &#34;&#34;&#34;
        if self.game_result != &#34;over&#34;: # game is not over, ask if he is sure about him quitting the game
            if messagebox.askokcancel(&#34;Quit&#34;, &#34;Are you sure you want to quit the game?&#34;):
                self.controller.messageChannel.setRequest(&#34;quitInMiddle&#34;, (self.game_ID, self.isSpectator))
                self.controller.show_page(MainPage)
        else:
            self.controller.show_page(MainPage)

    def exit_app(self):
        &#34;&#34;&#34;upon clicking the &#39;exit&#39; button, handle exiting the game gracefully by sending a message
            to the server
        &#34;&#34;&#34;
        if self.game_result != &#34;over&#34;:
            if messagebox.askokcancel(&#34;Exit&#34;, &#34;Are you sure you want to exit the application?&#34;):
                self.controller.messageChannel.setRequest(&#34;exit&#34;, (self.game_ID, self.isSpectator))
        else:
            self.controller.messageChannel.setRequest(&#34;exit&#34;, &#34;a&#34;)
        


##########################################################
##########################################################
##########################################################

def schedule_check(tk : tk.Tk, t : threading.Thread, func_name):
    &#34;&#34;&#34;Schedule the execution of the &#39;check_if_done()&#39; function after
        one second.

    Args:
        tk (tk.Tk): the frame from which the function was called
        t (threading.Thread): the thread that we monitor if it finished its work
        func_name: the name (not &#39;str&#39;) of the function to call after some time defined in the argument to &#39;after&#39; function
    &#34;&#34;&#34;
    func = getattr(tk,func_name)
    tk.after(500, func, t)

def validate_numbers_entry(text):
    &#34;&#34;&#34;function to help validate an entry text if it has numbers only
    &#34;&#34;&#34;
    return text.isdecimal()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Presentation.schedule_check"><code class="name flex">
<span>def <span class="ident">schedule_check</span></span>(<span>tk:tkinter.Tk, t:threading.Thread, func_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Schedule the execution of the 'check_if_done()' function after
one second.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tk</code></strong> :&ensp;<code>tk.Tk</code></dt>
<dd>the frame from which the function was called</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>threading.Thread</code></dt>
<dd>the thread that we monitor if it finished its work</dd>
<dt><strong><code>func_name</code></strong></dt>
<dd>the name (not 'str') of the function to call after some time defined in the argument to 'after' function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def schedule_check(tk : tk.Tk, t : threading.Thread, func_name):
    &#34;&#34;&#34;Schedule the execution of the &#39;check_if_done()&#39; function after
        one second.

    Args:
        tk (tk.Tk): the frame from which the function was called
        t (threading.Thread): the thread that we monitor if it finished its work
        func_name: the name (not &#39;str&#39;) of the function to call after some time defined in the argument to &#39;after&#39; function
    &#34;&#34;&#34;
    func = getattr(tk,func_name)
    tk.after(500, func, t)</code></pre>
</details>
</dd>
<dt id="Presentation.validate_numbers_entry"><code class="name flex">
<span>def <span class="ident">validate_numbers_entry</span></span>(<span>text)</span>
</code></dt>
<dd>
<div class="desc"><p>function to help validate an entry text if it has numbers only</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_numbers_entry(text):
    &#34;&#34;&#34;function to help validate an entry text if it has numbers only
    &#34;&#34;&#34;
    return text.isdecimal()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Presentation.AuthPageToken"><code class="flex name class">
<span>class <span class="ident">AuthPageToken</span></span>
<span>(</span><span>master, controller)</span>
</code></dt>
<dd>
<div class="desc"><p>Page for signing in to the system. This is the entry page of the application</p>
<p>Construct the object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>master</code></strong> :&ensp;<code>tk.Frame</code></dt>
<dd>the container frame</dd>
<dt><strong><code>controller</code></strong> :&ensp;<code>AppRoot</code></dt>
<dd>the controller of the app</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AuthPageToken(tk.Frame):
    &#34;&#34;&#34;Page for signing in to the system. This is the entry page of the application
    &#34;&#34;&#34;
    def __init__(self, master, controller):
        &#34;&#34;&#34;Construct the object

        Args:
            master (tk.Frame): the container frame
            controller (AppRoot): the controller of the app
        &#34;&#34;&#34;
        tk.Frame.__init__(self, master)
        
        self.master = master
        self.controller = controller
        self.configure(bg=&#34;#f0f0f0&#34;)
        self.create_widgets()           # call the function that create the graphical elements


    def create_widgets(self):
        &#34;&#34;&#34;create the graphical elements and define their properties
        &#34;&#34;&#34;
        # Create headline
        headline_label = ttk.Label(self, text=&#34;Tic Tac Toe&#34;, font=LARGEFONT, background=&#39;#F0F0F0&#39;, foreground=&#39;#333333&#39;)
        headline_label.pack(pady=10)
        
        # Group auth objects
        detailsFrame = tk.Frame(self, bg=&#34;#F0F0F0&#34;, highlightbackground=&#34;#F0F0F0&#34;, highlightthickness=0)
        detailsFrame.place(relx=0.5, rely=0.5, anchor=&#34;center&#34;)

        # Create token label and token entry
        token_label = ttk.Label(detailsFrame, text=&#34;Enter Your Token: &#34;, font=MEDIUMFONT, background=&#39;#F0F0F0&#39;, foreground=&#39;#333333&#39;)
        token_label.grid(row=0, column=0, pady=(0, 20), sticky=&#34;e&#34;)
        self.token_entry = tk.Entry(detailsFrame, font=(&#34;Verdana&#34;, 18))
        self.token_entry.grid(row=0, column=1, pady=(0, 20), sticky=&#34;w&#34;)
        self.token_entry.focus_set()
        
        # Create login button
        self.login_button = tk.Button(detailsFrame, text=&#34;Log in&#34;, command=self.authenticate, font=(&#34;Verdana&#34;, 18), bg=&#39;#4CAF50&#39;, fg=&#39;white&#39;)
        self.login_button.grid(row=2, column=0, columnspan=2, pady=(20, 50), sticky=&#34;n&#34;)
        
        # Message label
        self.message_label = ttk.Label(detailsFrame, text=&#34;&#34;, font=MEDIUMFONT, background=&#39;#F0F0F0&#39;, foreground=&#39;#333333&#39;)
        self.message_label.grid(row=3, column=0, pady=(0, 20), sticky=&#34;e&#34;)
        

        # Create Exit button
        exit_button = tk.Button(self, text=&#34; Exit &#34;, command=self.exitTheGame, font=(&#34;Verdana&#34;, 18), bg=&#39;#4CAF50&#39;, fg=&#39;white&#39;)
        exit_button.place(relx=0.6, rely=0.9)

        
        # Create Sign Up button
        signup_button = tk.Button(self, text=&#34;Sign Up&#34;, command=lambda: self.controller.show_page(SignUpPage), font=(&#34;Verdana&#34;, 18), bg=&#39;#4CAF50&#39;, fg=&#39;white&#39;)
        signup_button.place(relx=0.3, rely=0.9)

    
    def authenticate(self):
        &#34;&#34;&#34;manage the authentication process using unique token
        &#34;&#34;&#34;
        self.message_label.config(text = &#34;&#34;)        # clear the message label, just in case
        self.login_button[&#34;state&#34;] = &#34;disabled&#34;     # disable the &#39;login&#39; button until an answer from the server will be received
        
        token = self.token_entry.get()              # get the &#39;token&#39; input of the user
        self.controller.messageChannel.setRequest(&#34;veteranUser&#34;, token) # send a request to check validity of the token

        t = threading.Thread(target=self.authenticate_helper)
        t.start()

        # check periodically for a response from the server and handle a response in &#39;check_if_auth_done&#39;
        schedule_check(self, t, self.check_if_auth_done.__name__)


    def authenticate_helper(self):
        &#34;&#34;&#34;check if a response from the server about the &#39;auth&#39; request has arrived.
            At first we check if the response is None, i.e. no response has arrived, and then we verify
            that the response is what we expected to, i.e. &#34;response&#34; == &#34;0_verified&#34;, else we continue looping.
        &#34;&#34;&#34;
        while (self.controller.messageChannel.responses == []  or
               self.controller.messageChannel.responses[0][&#34;response&#34;][0] != &#34;0&#34;):
            pass


    def check_if_auth_done(self, t):
        &#34;&#34;&#34;if the thread &#39;t&#39; is dead then it means a response from the server about the auth request has arrived,
            the function handle that response

        Args:
            t (Thread): the thread that is in charge of checking if an auth response has arrived
        &#34;&#34;&#34;
        # If the thread has finished, re-enable the button and show a message.
        if not t.is_alive():
            self.login_button[&#34;state&#34;] = &#34;normal&#34;  # re-enable the button
            match self.controller.messageChannel.responses[0][&#34;response&#34;]: # examine the response
                # the user token is a verified user, move to the next frame
                case &#34;0_verified&#34;:
                    if self.controller.currentPage is AuthPageToken:
                        self.controller.show_page(MainPage)
                
                # the user is already registered, refuse the request for this process
                case &#34;0_AlreadyRegistered&#34;:
                    self.message_label.config(text = &#34;this user is already registered&#34;)
                
                # there is no token like the user inserted in the database
                case &#34;0_tokenNotFound&#34;:
                    self.message_label.config(text = &#34;this token was not found&#34;)
            
            # pop the response from the queue of responses
            self.controller.messageChannel.responses.pop(0)

        else:
            # Otherwise check again after one second
            schedule_check(self, t, self.check_if_auth_done.__name__)


    def exitTheGame(self):
        &#34;&#34;&#34;upon clicking the &#39;exit&#39; button, handle exiting the game gracefully by sending a message
            to the server
        &#34;&#34;&#34;
        self.controller.messageChannel.setRequest(&#34;exit&#34;, &#34;a&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Presentation.AuthPageToken.authenticate"><code class="name flex">
<span>def <span class="ident">authenticate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>manage the authentication process using unique token</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def authenticate(self):
    &#34;&#34;&#34;manage the authentication process using unique token
    &#34;&#34;&#34;
    self.message_label.config(text = &#34;&#34;)        # clear the message label, just in case
    self.login_button[&#34;state&#34;] = &#34;disabled&#34;     # disable the &#39;login&#39; button until an answer from the server will be received
    
    token = self.token_entry.get()              # get the &#39;token&#39; input of the user
    self.controller.messageChannel.setRequest(&#34;veteranUser&#34;, token) # send a request to check validity of the token

    t = threading.Thread(target=self.authenticate_helper)
    t.start()

    # check periodically for a response from the server and handle a response in &#39;check_if_auth_done&#39;
    schedule_check(self, t, self.check_if_auth_done.__name__)</code></pre>
</details>
</dd>
<dt id="Presentation.AuthPageToken.authenticate_helper"><code class="name flex">
<span>def <span class="ident">authenticate_helper</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>check if a response from the server about the 'auth' request has arrived.
At first we check if the response is None, i.e. no response has arrived, and then we verify
that the response is what we expected to, i.e. "response" == "0_verified", else we continue looping.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def authenticate_helper(self):
    &#34;&#34;&#34;check if a response from the server about the &#39;auth&#39; request has arrived.
        At first we check if the response is None, i.e. no response has arrived, and then we verify
        that the response is what we expected to, i.e. &#34;response&#34; == &#34;0_verified&#34;, else we continue looping.
    &#34;&#34;&#34;
    while (self.controller.messageChannel.responses == []  or
           self.controller.messageChannel.responses[0][&#34;response&#34;][0] != &#34;0&#34;):
        pass</code></pre>
</details>
</dd>
<dt id="Presentation.AuthPageToken.check_if_auth_done"><code class="name flex">
<span>def <span class="ident">check_if_auth_done</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"><p>if the thread 't' is dead then it means a response from the server about the auth request has arrived,
the function handle that response</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>Thread</code></dt>
<dd>the thread that is in charge of checking if an auth response has arrived</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_if_auth_done(self, t):
    &#34;&#34;&#34;if the thread &#39;t&#39; is dead then it means a response from the server about the auth request has arrived,
        the function handle that response

    Args:
        t (Thread): the thread that is in charge of checking if an auth response has arrived
    &#34;&#34;&#34;
    # If the thread has finished, re-enable the button and show a message.
    if not t.is_alive():
        self.login_button[&#34;state&#34;] = &#34;normal&#34;  # re-enable the button
        match self.controller.messageChannel.responses[0][&#34;response&#34;]: # examine the response
            # the user token is a verified user, move to the next frame
            case &#34;0_verified&#34;:
                if self.controller.currentPage is AuthPageToken:
                    self.controller.show_page(MainPage)
            
            # the user is already registered, refuse the request for this process
            case &#34;0_AlreadyRegistered&#34;:
                self.message_label.config(text = &#34;this user is already registered&#34;)
            
            # there is no token like the user inserted in the database
            case &#34;0_tokenNotFound&#34;:
                self.message_label.config(text = &#34;this token was not found&#34;)
        
        # pop the response from the queue of responses
        self.controller.messageChannel.responses.pop(0)

    else:
        # Otherwise check again after one second
        schedule_check(self, t, self.check_if_auth_done.__name__)</code></pre>
</details>
</dd>
<dt id="Presentation.AuthPageToken.create_widgets"><code class="name flex">
<span>def <span class="ident">create_widgets</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>create the graphical elements and define their properties</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_widgets(self):
    &#34;&#34;&#34;create the graphical elements and define their properties
    &#34;&#34;&#34;
    # Create headline
    headline_label = ttk.Label(self, text=&#34;Tic Tac Toe&#34;, font=LARGEFONT, background=&#39;#F0F0F0&#39;, foreground=&#39;#333333&#39;)
    headline_label.pack(pady=10)
    
    # Group auth objects
    detailsFrame = tk.Frame(self, bg=&#34;#F0F0F0&#34;, highlightbackground=&#34;#F0F0F0&#34;, highlightthickness=0)
    detailsFrame.place(relx=0.5, rely=0.5, anchor=&#34;center&#34;)

    # Create token label and token entry
    token_label = ttk.Label(detailsFrame, text=&#34;Enter Your Token: &#34;, font=MEDIUMFONT, background=&#39;#F0F0F0&#39;, foreground=&#39;#333333&#39;)
    token_label.grid(row=0, column=0, pady=(0, 20), sticky=&#34;e&#34;)
    self.token_entry = tk.Entry(detailsFrame, font=(&#34;Verdana&#34;, 18))
    self.token_entry.grid(row=0, column=1, pady=(0, 20), sticky=&#34;w&#34;)
    self.token_entry.focus_set()
    
    # Create login button
    self.login_button = tk.Button(detailsFrame, text=&#34;Log in&#34;, command=self.authenticate, font=(&#34;Verdana&#34;, 18), bg=&#39;#4CAF50&#39;, fg=&#39;white&#39;)
    self.login_button.grid(row=2, column=0, columnspan=2, pady=(20, 50), sticky=&#34;n&#34;)
    
    # Message label
    self.message_label = ttk.Label(detailsFrame, text=&#34;&#34;, font=MEDIUMFONT, background=&#39;#F0F0F0&#39;, foreground=&#39;#333333&#39;)
    self.message_label.grid(row=3, column=0, pady=(0, 20), sticky=&#34;e&#34;)
    

    # Create Exit button
    exit_button = tk.Button(self, text=&#34; Exit &#34;, command=self.exitTheGame, font=(&#34;Verdana&#34;, 18), bg=&#39;#4CAF50&#39;, fg=&#39;white&#39;)
    exit_button.place(relx=0.6, rely=0.9)

    
    # Create Sign Up button
    signup_button = tk.Button(self, text=&#34;Sign Up&#34;, command=lambda: self.controller.show_page(SignUpPage), font=(&#34;Verdana&#34;, 18), bg=&#39;#4CAF50&#39;, fg=&#39;white&#39;)
    signup_button.place(relx=0.3, rely=0.9)</code></pre>
</details>
</dd>
<dt id="Presentation.AuthPageToken.exitTheGame"><code class="name flex">
<span>def <span class="ident">exitTheGame</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>upon clicking the 'exit' button, handle exiting the game gracefully by sending a message
to the server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exitTheGame(self):
    &#34;&#34;&#34;upon clicking the &#39;exit&#39; button, handle exiting the game gracefully by sending a message
        to the server
    &#34;&#34;&#34;
    self.controller.messageChannel.setRequest(&#34;exit&#34;, &#34;a&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Presentation.GamePage"><code class="flex name class">
<span>class <span class="ident">GamePage</span></span>
<span>(</span><span>parent, controller, num_of_players:int, game_ID:str='', board='', isSpectator=False)</span>
</code></dt>
<dd>
<div class="desc"><p>page for displaying the game elements and handle events about it</p>
<p>construct the 'GamePage' object, initialize board, timer and messages</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>tk.Frame</code></dt>
<dd>a frame that inherits from the app root</dd>
<dt><strong><code>controller</code></strong> :&ensp;<code>AppRoot</code></dt>
<dd>the controller of the app</dd>
<dt><strong><code>num_of_players</code></strong> :&ensp;<code>int</code></dt>
<dd>number of players (for building the board with the right size)</dd>
<dt><strong><code>game_ID</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>ID of the game. Defaults to "".</dd>
<dt><strong><code>board</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>game grid. Defaults to "".</dd>
<dt><strong><code>isSpectator</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>a flag to know if the user chose to be a spectator or a player. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GamePage(tk.Frame):
    &#34;&#34;&#34;page for displaying the game elements and handle events about it
    &#34;&#34;&#34;
    def __init__(self, parent, controller, num_of_players : int,  game_ID: str = &#34;&#34;, board = &#34;&#34;, isSpectator = False):
        &#34;&#34;&#34;construct the &#39;GamePage&#39; object, initialize board, timer and messages

        Args:
            parent (tk.Frame): a frame that inherits from the app root
            controller (AppRoot): the controller of the app
            num_of_players (int): number of players (for building the board with the right size)
            game_ID (str, optional): ID of the game. Defaults to &#34;&#34;.
            board (str, optional): game grid. Defaults to &#34;&#34;.
            isSpectator (bool, optional): a flag to know if the user chose to be a spectator or a player. Defaults to False.
        &#34;&#34;&#34;
        tk.Frame.__init__(self, parent)
        self.master = parent
        self.controller = controller
        self.game_ID = game_ID
        self.size = num_of_players + 1  # size of board in x and y axis
        self.configure(bg=&#34;#f0f0f0&#34;)    # Set background color
        
        # if a spectator has joined in the middle of a game, we need to initialize his board
        if board != &#34;&#34;:
            self.board = board
        else:
            self.board = [[&#39; &#39; for _ in range(self.size)] for _ in range(self.size)]

        
        self.symbol_player = &#39;no&#39;
        self.isSpectator = isSpectator

        self.isStarted = False # flag primarly for staring the timer
        self.yourTurn = False  # flag to know if it&#39;s the turn of this player

        self.message_buffer = []

        self.game_result = &#34;waiting&#34; # game status
        self.secondsForTimeout = 30  # put here no more than 59

        self.create_widgets()
        self.update_timer_and_messages()

    def create_widgets(self):
        &#34;&#34;&#34;create the graphical elements and define their properties
        &#34;&#34;&#34;
        # Frame for the grid
        self.grid_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
        self.grid_frame.grid(row=0, column=0, padx=10, pady=10, sticky=&#34;nsew&#34;)

        self.buttons = [[None for _ in range(self.size)] for _ in range(self.size)]
        for i in range(self.size):
            self.grid_frame.grid_columnconfigure(i, weight=1)  # Expand columns equally
            self.grid_frame.grid_rowconfigure(i, weight=1)     # Expand rows equally
            for j in range(self.size):
                self.buttons[i][j] = tk.Button(self.grid_frame, text=self.board[i][j], font=(&#39;Arial&#39;, 16, &#39;bold&#39;), width=3, height=1,
                                                command=lambda i=i, j=j: self.on_button_click(i, j), bg=&#34;#ffffff&#34;, fg=&#34;#000000&#34;, bd=1, relief=&#34;solid&#34;)
                self.buttons[i][j].grid(row=i, column=j, sticky=&#34;nsew&#34;)
                
        
        # Frame for buttons and timer
        self.control_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
        self.control_frame.grid(row=0, column=1, padx=0, pady=0, sticky=&#34;n&#34;)
        self.control_frame.grid_propagate(False)

        self.buttons_frame = tk.Frame(self.control_frame, bg=&#34;#f0f0f0&#34;)
        self.buttons_frame.pack(side=&#34;top&#34;, fill=&#34;y&#34;, padx=0, pady=0)

        self.quit_button = tk.Button(self.buttons_frame, text=&#34;Quit Game&#34;, command=self.quit_game, font=(&#39;Arial&#39;, 12), bg=&#34;#d32f2f&#34;, fg=&#34;#ffffff&#34;, bd=1, relief=&#34;solid&#34;)
        self.quit_button.grid(row=0, column=0, pady=5, padx=5, sticky=&#34;ew&#34;)

        self.exit_button = tk.Button(self.buttons_frame, text=&#34;Exit&#34;, command=self.exit_app, font=(&#39;Arial&#39;, 12), bg=&#34;#303f9f&#34;, fg=&#34;#ffffff&#34;, bd=1, relief=&#34;solid&#34;)
        self.exit_button.grid(row=1, column=0, pady=5, padx=5, sticky=&#34;ew&#34;)

        self.timer_label = tk.Label(self.buttons_frame, text=&#34;&#34;, font=(&#39;Arial&#39;, 12), bg=&#34;#f0f0f0&#34;)
        self.timer_label.grid(row=2, column=0, pady=5, padx=5, sticky=&#34;ew&#34;)

        self.catchSpace_label = tk.Label(self.buttons_frame, text=&#34;&#34;, font=(&#39;Arial&#39;, 12), bg=&#34;#f0f0f0&#34;)
        self.catchSpace_label.grid(row=3, column=0, pady=5, padx=5, sticky=&#34;ew&#34;)

        self.game_turn_label = tk.Label(self.control_frame, text=&#34;you&#39;ll  wait&#34;, pady=10, padx=20, font=(&#39;Arial&#39;, 20), bg=&#34;#404040&#34;, fg=&#34;#ffffff&#34;)
        self.game_turn_label.pack(side=&#34;bottom&#34;, fill=&#34;y&#34;, padx=0, pady=5)

        self.spectator_label = tk.Label(self.control_frame, text=&#34;spectator&#34;, pady=10, padx=20, font=(&#39;Arial&#39;, 20), bg=&#34;#cc00cc&#34;, fg=&#34;#ffffff&#34;)
        self.spectator_label.pack(side=&#34;bottom&#34;, fill=&#34;y&#34;, padx=0, pady=5)
        self.spectator_label.pack_forget()

        # Frame for messages with scrollable area
        self.message_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
        self.message_frame.grid(row=1, column=0, columnspan=2, padx=10, pady=10, sticky=&#34;nsew&#34;)

        self.message_scrollbar = tk.Scrollbar(self.message_frame)
        self.message_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        self.message_text = tk.Text(self.message_frame, height=5, width=50, font=(&#39;Arial&#39;, 12), bg=&#34;#ffffff&#34;, fg=&#34;#000000&#34;, bd=1, relief=&#34;solid&#34;)
        self.message_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.message_text.config(state=tk.DISABLED)  # Make text area read-only

        self.message_scrollbar.config(command=self.message_text.yview)
        self.message_text.config(yscrollcommand=self.message_scrollbar.set)

        # Configure row and column weights to make the message frame stretchable
        self.grid_rowconfigure(0, weight=1)
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=1)
        self.grid_columnconfigure(1, weight=1)
    
    def assignSymbol(self, symbol: int) -&gt; str:
        &#34;&#34;&#34;assign the symmbol fir this player and return it

        Args:
            symbol (int): the int representation of the symbol

        Returns:
            str: the symbol as string (&#39;O&#39;, &#39;X&#39;, etc.)
        &#34;&#34;&#34;
        self.symbol_player = symbol
        return symbol

    def restartTimer(self):
        &#34;&#34;&#34;restart the timer by updating the start_time variable to the current time
        &#34;&#34;&#34;
        self.start_time = time.time()

    def on_button_click(self, row: int, col: int):
        &#34;&#34;&#34;handle the event of clicking of the board

        Args:
            row (int): row of the button clicked
            col (int): column of the button clicked
        &#34;&#34;&#34;
        if self.yourTurn  and  self.board[row][col] == &#39; &#39;:
                self.buttons[row][col][&#39;text&#39;] = self.symbol_player
                self.yourTurn = False # not your turn anymore

                # send a request about a button click on the boarf of the game
                self.controller.messageChannel.setRequest(&#34;aMove&#34;, ((row, col, self.symbol_player), self.game_ID))

    def updateBoardAndButton(self, row: int, col: int, symbol: str):
        &#34;&#34;&#34;update the board of game for display

        Args:
            row (int): row of button to update
            col (int): column of button to update
            symbol (str): string representation of the symbol of this player
        &#34;&#34;&#34;
        self.buttons[row][col][&#39;text&#39;] = symbol

    def update_timer_and_messages(self):
        &#34;&#34;&#34;update the timer the the board of messages
        &#34;&#34;&#34;
        if (len(self.message_buffer) &gt; 0):
            self.add_message(self.message_buffer.pop(0)) # add the message that just now poped out from the queue of messages
            
            
        if (self.isStarted):
            # calculate the new time in the timer and display it with some format
            elapsed_time = int(time.time() - self.start_time)
            minutes = elapsed_time // 60
            seconds = elapsed_time % 60
            self.timer_label.config(text=f&#34;Time: {minutes:02d}:{seconds:02d}&#34;)
        
            # handle timeout
            if (seconds == self.secondsForTimeout  and  self.yourTurn == True):
                self.yourTurn = False
                self.controller.messageChannel.setRequest(&#34;timeout&#34;, self.game_ID)
        
        # call again after 1 second
        self.timer_label.after(1000, self.update_timer_and_messages)

    def add_message(self, message: str):
        &#34;&#34;&#34;add a message to the message box

        Args:
            message (str): string of the message to add
        &#34;&#34;&#34;
        self.message_text.config(state=tk.NORMAL)  # Enable editing temporarily
        self.message_text.insert(tk.END, message + &#39;\n\n&#39;)
        self.message_text.config(state=tk.DISABLED)  # Make read-only again
        self.message_text.see(tk.END)  # Scroll to the bottom

    def quit_game(self):
        &#34;&#34;&#34;quit from the game, and notify other players if the game is not over
        &#34;&#34;&#34;
        if self.game_result != &#34;over&#34;: # game is not over, ask if he is sure about him quitting the game
            if messagebox.askokcancel(&#34;Quit&#34;, &#34;Are you sure you want to quit the game?&#34;):
                self.controller.messageChannel.setRequest(&#34;quitInMiddle&#34;, (self.game_ID, self.isSpectator))
                self.controller.show_page(MainPage)
        else:
            self.controller.show_page(MainPage)

    def exit_app(self):
        &#34;&#34;&#34;upon clicking the &#39;exit&#39; button, handle exiting the game gracefully by sending a message
            to the server
        &#34;&#34;&#34;
        if self.game_result != &#34;over&#34;:
            if messagebox.askokcancel(&#34;Exit&#34;, &#34;Are you sure you want to exit the application?&#34;):
                self.controller.messageChannel.setRequest(&#34;exit&#34;, (self.game_ID, self.isSpectator))
        else:
            self.controller.messageChannel.setRequest(&#34;exit&#34;, &#34;a&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Presentation.GamePage.add_message"><code class="name flex">
<span>def <span class="ident">add_message</span></span>(<span>self, message:str)</span>
</code></dt>
<dd>
<div class="desc"><p>add a message to the message box</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
<dd>string of the message to add</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_message(self, message: str):
    &#34;&#34;&#34;add a message to the message box

    Args:
        message (str): string of the message to add
    &#34;&#34;&#34;
    self.message_text.config(state=tk.NORMAL)  # Enable editing temporarily
    self.message_text.insert(tk.END, message + &#39;\n\n&#39;)
    self.message_text.config(state=tk.DISABLED)  # Make read-only again
    self.message_text.see(tk.END)  # Scroll to the bottom</code></pre>
</details>
</dd>
<dt id="Presentation.GamePage.assignSymbol"><code class="name flex">
<span>def <span class="ident">assignSymbol</span></span>(<span>self, symbol:int) >str</span>
</code></dt>
<dd>
<div class="desc"><p>assign the symmbol fir this player and return it</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>symbol</code></strong> :&ensp;<code>int</code></dt>
<dd>the int representation of the symbol</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the symbol as string ('O', 'X', etc.)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assignSymbol(self, symbol: int) -&gt; str:
    &#34;&#34;&#34;assign the symmbol fir this player and return it

    Args:
        symbol (int): the int representation of the symbol

    Returns:
        str: the symbol as string (&#39;O&#39;, &#39;X&#39;, etc.)
    &#34;&#34;&#34;
    self.symbol_player = symbol
    return symbol</code></pre>
</details>
</dd>
<dt id="Presentation.GamePage.create_widgets"><code class="name flex">
<span>def <span class="ident">create_widgets</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>create the graphical elements and define their properties</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_widgets(self):
    &#34;&#34;&#34;create the graphical elements and define their properties
    &#34;&#34;&#34;
    # Frame for the grid
    self.grid_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
    self.grid_frame.grid(row=0, column=0, padx=10, pady=10, sticky=&#34;nsew&#34;)

    self.buttons = [[None for _ in range(self.size)] for _ in range(self.size)]
    for i in range(self.size):
        self.grid_frame.grid_columnconfigure(i, weight=1)  # Expand columns equally
        self.grid_frame.grid_rowconfigure(i, weight=1)     # Expand rows equally
        for j in range(self.size):
            self.buttons[i][j] = tk.Button(self.grid_frame, text=self.board[i][j], font=(&#39;Arial&#39;, 16, &#39;bold&#39;), width=3, height=1,
                                            command=lambda i=i, j=j: self.on_button_click(i, j), bg=&#34;#ffffff&#34;, fg=&#34;#000000&#34;, bd=1, relief=&#34;solid&#34;)
            self.buttons[i][j].grid(row=i, column=j, sticky=&#34;nsew&#34;)
            
    
    # Frame for buttons and timer
    self.control_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
    self.control_frame.grid(row=0, column=1, padx=0, pady=0, sticky=&#34;n&#34;)
    self.control_frame.grid_propagate(False)

    self.buttons_frame = tk.Frame(self.control_frame, bg=&#34;#f0f0f0&#34;)
    self.buttons_frame.pack(side=&#34;top&#34;, fill=&#34;y&#34;, padx=0, pady=0)

    self.quit_button = tk.Button(self.buttons_frame, text=&#34;Quit Game&#34;, command=self.quit_game, font=(&#39;Arial&#39;, 12), bg=&#34;#d32f2f&#34;, fg=&#34;#ffffff&#34;, bd=1, relief=&#34;solid&#34;)
    self.quit_button.grid(row=0, column=0, pady=5, padx=5, sticky=&#34;ew&#34;)

    self.exit_button = tk.Button(self.buttons_frame, text=&#34;Exit&#34;, command=self.exit_app, font=(&#39;Arial&#39;, 12), bg=&#34;#303f9f&#34;, fg=&#34;#ffffff&#34;, bd=1, relief=&#34;solid&#34;)
    self.exit_button.grid(row=1, column=0, pady=5, padx=5, sticky=&#34;ew&#34;)

    self.timer_label = tk.Label(self.buttons_frame, text=&#34;&#34;, font=(&#39;Arial&#39;, 12), bg=&#34;#f0f0f0&#34;)
    self.timer_label.grid(row=2, column=0, pady=5, padx=5, sticky=&#34;ew&#34;)

    self.catchSpace_label = tk.Label(self.buttons_frame, text=&#34;&#34;, font=(&#39;Arial&#39;, 12), bg=&#34;#f0f0f0&#34;)
    self.catchSpace_label.grid(row=3, column=0, pady=5, padx=5, sticky=&#34;ew&#34;)

    self.game_turn_label = tk.Label(self.control_frame, text=&#34;you&#39;ll  wait&#34;, pady=10, padx=20, font=(&#39;Arial&#39;, 20), bg=&#34;#404040&#34;, fg=&#34;#ffffff&#34;)
    self.game_turn_label.pack(side=&#34;bottom&#34;, fill=&#34;y&#34;, padx=0, pady=5)

    self.spectator_label = tk.Label(self.control_frame, text=&#34;spectator&#34;, pady=10, padx=20, font=(&#39;Arial&#39;, 20), bg=&#34;#cc00cc&#34;, fg=&#34;#ffffff&#34;)
    self.spectator_label.pack(side=&#34;bottom&#34;, fill=&#34;y&#34;, padx=0, pady=5)
    self.spectator_label.pack_forget()

    # Frame for messages with scrollable area
    self.message_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
    self.message_frame.grid(row=1, column=0, columnspan=2, padx=10, pady=10, sticky=&#34;nsew&#34;)

    self.message_scrollbar = tk.Scrollbar(self.message_frame)
    self.message_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    self.message_text = tk.Text(self.message_frame, height=5, width=50, font=(&#39;Arial&#39;, 12), bg=&#34;#ffffff&#34;, fg=&#34;#000000&#34;, bd=1, relief=&#34;solid&#34;)
    self.message_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    self.message_text.config(state=tk.DISABLED)  # Make text area read-only

    self.message_scrollbar.config(command=self.message_text.yview)
    self.message_text.config(yscrollcommand=self.message_scrollbar.set)

    # Configure row and column weights to make the message frame stretchable
    self.grid_rowconfigure(0, weight=1)
    self.grid_columnconfigure(0, weight=1)
    self.grid_rowconfigure(1, weight=1)
    self.grid_columnconfigure(1, weight=1)</code></pre>
</details>
</dd>
<dt id="Presentation.GamePage.exit_app"><code class="name flex">
<span>def <span class="ident">exit_app</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>upon clicking the 'exit' button, handle exiting the game gracefully by sending a message
to the server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exit_app(self):
    &#34;&#34;&#34;upon clicking the &#39;exit&#39; button, handle exiting the game gracefully by sending a message
        to the server
    &#34;&#34;&#34;
    if self.game_result != &#34;over&#34;:
        if messagebox.askokcancel(&#34;Exit&#34;, &#34;Are you sure you want to exit the application?&#34;):
            self.controller.messageChannel.setRequest(&#34;exit&#34;, (self.game_ID, self.isSpectator))
    else:
        self.controller.messageChannel.setRequest(&#34;exit&#34;, &#34;a&#34;)</code></pre>
</details>
</dd>
<dt id="Presentation.GamePage.on_button_click"><code class="name flex">
<span>def <span class="ident">on_button_click</span></span>(<span>self, row:int, col:int)</span>
</code></dt>
<dd>
<div class="desc"><p>handle the event of clicking of the board</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>row</code></strong> :&ensp;<code>int</code></dt>
<dd>row of the button clicked</dd>
<dt><strong><code>col</code></strong> :&ensp;<code>int</code></dt>
<dd>column of the button clicked</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_button_click(self, row: int, col: int):
    &#34;&#34;&#34;handle the event of clicking of the board

    Args:
        row (int): row of the button clicked
        col (int): column of the button clicked
    &#34;&#34;&#34;
    if self.yourTurn  and  self.board[row][col] == &#39; &#39;:
            self.buttons[row][col][&#39;text&#39;] = self.symbol_player
            self.yourTurn = False # not your turn anymore

            # send a request about a button click on the boarf of the game
            self.controller.messageChannel.setRequest(&#34;aMove&#34;, ((row, col, self.symbol_player), self.game_ID))</code></pre>
</details>
</dd>
<dt id="Presentation.GamePage.quit_game"><code class="name flex">
<span>def <span class="ident">quit_game</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>quit from the game, and notify other players if the game is not over</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quit_game(self):
    &#34;&#34;&#34;quit from the game, and notify other players if the game is not over
    &#34;&#34;&#34;
    if self.game_result != &#34;over&#34;: # game is not over, ask if he is sure about him quitting the game
        if messagebox.askokcancel(&#34;Quit&#34;, &#34;Are you sure you want to quit the game?&#34;):
            self.controller.messageChannel.setRequest(&#34;quitInMiddle&#34;, (self.game_ID, self.isSpectator))
            self.controller.show_page(MainPage)
    else:
        self.controller.show_page(MainPage)</code></pre>
</details>
</dd>
<dt id="Presentation.GamePage.restartTimer"><code class="name flex">
<span>def <span class="ident">restartTimer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>restart the timer by updating the start_time variable to the current time</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restartTimer(self):
    &#34;&#34;&#34;restart the timer by updating the start_time variable to the current time
    &#34;&#34;&#34;
    self.start_time = time.time()</code></pre>
</details>
</dd>
<dt id="Presentation.GamePage.updateBoardAndButton"><code class="name flex">
<span>def <span class="ident">updateBoardAndButton</span></span>(<span>self, row:int, col:int, symbol:str)</span>
</code></dt>
<dd>
<div class="desc"><p>update the board of game for display</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>row</code></strong> :&ensp;<code>int</code></dt>
<dd>row of button to update</dd>
<dt><strong><code>col</code></strong> :&ensp;<code>int</code></dt>
<dd>column of button to update</dd>
<dt><strong><code>symbol</code></strong> :&ensp;<code>str</code></dt>
<dd>string representation of the symbol of this player</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateBoardAndButton(self, row: int, col: int, symbol: str):
    &#34;&#34;&#34;update the board of game for display

    Args:
        row (int): row of button to update
        col (int): column of button to update
        symbol (str): string representation of the symbol of this player
    &#34;&#34;&#34;
    self.buttons[row][col][&#39;text&#39;] = symbol</code></pre>
</details>
</dd>
<dt id="Presentation.GamePage.update_timer_and_messages"><code class="name flex">
<span>def <span class="ident">update_timer_and_messages</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>update the timer the the board of messages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_timer_and_messages(self):
    &#34;&#34;&#34;update the timer the the board of messages
    &#34;&#34;&#34;
    if (len(self.message_buffer) &gt; 0):
        self.add_message(self.message_buffer.pop(0)) # add the message that just now poped out from the queue of messages
        
        
    if (self.isStarted):
        # calculate the new time in the timer and display it with some format
        elapsed_time = int(time.time() - self.start_time)
        minutes = elapsed_time // 60
        seconds = elapsed_time % 60
        self.timer_label.config(text=f&#34;Time: {minutes:02d}:{seconds:02d}&#34;)
    
        # handle timeout
        if (seconds == self.secondsForTimeout  and  self.yourTurn == True):
            self.yourTurn = False
            self.controller.messageChannel.setRequest(&#34;timeout&#34;, self.game_ID)
    
    # call again after 1 second
    self.timer_label.after(1000, self.update_timer_and_messages)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Presentation.MainPage"><code class="flex name class">
<span>class <span class="ident">MainPage</span></span>
<span>(</span><span>master, controller)</span>
</code></dt>
<dd>
<div class="desc"><p>Page for main menu of the app</p>
<p>constructor for SignUpPage</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>tk.Frame</code></dt>
<dd>a frame that inherits from the app root</dd>
<dt><strong><code>controller</code></strong> :&ensp;<code>AppRoot</code></dt>
<dd>the controller of the app</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MainPage(tk.Frame):
    &#34;&#34;&#34;Page for main menu of the app
    &#34;&#34;&#34;
    def __init__(self, master, controller):
        &#34;&#34;&#34;constructor for SignUpPage

        Args:
            parent (tk.Frame): a frame that inherits from the app root
            controller (AppRoot): the controller of the app
        &#34;&#34;&#34;
        tk.Frame.__init__(self, master)
        
        self.master = master
        self.controller = controller
        self.configure(bg=&#34;#f0f0f0&#34;)
        self.create_widgets() # call the function that create the graphical elements


    def create_widgets(self):
        &#34;&#34;&#34;create the graphical elements and define their properties
        &#34;&#34;&#34;
        # Headline label
        headline_label = tk.Label(self, text=&#34;Game Center&#34;, font=(&#34;Verdana&#34;, 24, &#34;bold&#34;), bg=&#34;#f0f0f0&#34;)
        headline_label.pack(pady=10)

        # Buttons frame
        self.buttons_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
        self.buttons_frame.pack()

        # New Game button
        self.new_game_button = tk.Button(self.buttons_frame, text=&#34;New Game&#34;, width=15, font=(&#34;Verdana&#34;, 12), bg=&#34;#4CAF50&#34;, fg=&#34;white&#34;, relief=tk.FLAT, command=self.new_game)
        self.new_game_button.grid(row=0, column=0, padx=10)

        # Join a Game button
        self.join_game_button = tk.Button(self.buttons_frame, text=&#34;Join a Game&#34;, width=15, font=(&#34;Arial&#34;, 12), bg=&#34;#FFC107&#34;, fg=&#34;white&#34;, relief=tk.FLAT, command=self.join_game)
        self.join_game_button.grid(row=0, column=1, padx=10)

        # View Leadership Games button
        view_games_button = tk.Button(self.buttons_frame, text=&#34;View Leadership Games&#34;, width=20, font=(&#34;Arial&#34;, 12), bg=&#34;#2196F3&#34;, fg=&#34;white&#34;, relief=tk.FLAT, command=lambda: self.controller.show_page(StatisticsPage))
        view_games_button.grid(row=0, column=2, padx=10)

        # Games list frame (initially hidden)
        self.games_list_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
        self.games_list_frame.pack()

        # Listbox for games
        self.games_listbox = tk.Listbox(self.games_list_frame, width=50, height=10, font=(&#34;Arial&#34;, 12), bg=&#34;white&#34;, selectbackground=&#34;#FFC107&#34;)
        self.games_listbox.pack(side=&#34;left&#34;, fill=&#34;y&#34;, padx=5, pady=5)
        
        # Bind callback function to listbox selection event
        self.games_listbox.bind(&#34;&lt;Double-Button-1&gt;&#34;, self.on_game_select)
        
        # Scrollbar for listbox
        scrollbar = tk.Scrollbar(self.games_list_frame, orient=&#34;vertical&#34;, command=self.games_listbox.yview)
        scrollbar.pack(side=&#34;right&#34;, fill=&#34;y&#34;)

        # Configure listbox to use scrollbar
        self.games_listbox.config(yscrollcommand=scrollbar.set)


        self.activeGames_initialized = []
        self.activeGames_occuring = []

        # Text entry for number of players (initially hidden)
        self.players_entry_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
        self.players_entry_label = tk.Label(self.players_entry_frame, text=&#34;Number of Players:&#34;, font=(&#34;Verdana&#34;, 12), bg=&#34;#f0f0f0&#34;)
        self.players_entry_label.pack(side=&#34;left&#34;, padx=5, pady=5)
        self.players_entry = tk.Entry(self.players_entry_frame, font=(&#34;Arial&#34;, 12), width=10, justify=&#39;center&#39;)
        self.players_entry.pack(side=&#34;left&#34;, padx=5, pady=5)
        self.players_entry_frame.pack()

        # Radio buttons for player type (initially hidden)
        self.player_type_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
        self.player_type_label = tk.Label(self.player_type_frame, text=&#34;Player Type:&#34;, font=(&#34;Arial&#34;, 12), bg=&#34;#f0f0f0&#34;)
        self.player_type_label.pack(side=&#34;left&#34;, padx=5, pady=5)

        self.player_type_var = tk.StringVar(value=&#34;active_player&#34;)
        self.player_last_type = &#34;active_player&#34; # used to verify that the user changed the radio button selection
                                                # and not just clicked on the same button

        style = ttk.Style()
        style.configure(&#34;TRadiobutton&#34;, background=&#34;#f0f0f0&#34;, font=(&#34;Arial&#34;, 12))

        self.active_player_radio = ttk.Radiobutton(self.player_type_frame, text=&#34;Active Player&#34;, variable=self.player_type_var, value=&#34;active_player&#34;, command=self.handle_radio_click)
        self.active_player_radio.pack(side=&#34;left&#34;, padx=5, pady=5)

        self.spectator_radio = ttk.Radiobutton(self.player_type_frame, text=&#34;Spectator&#34;, variable=self.player_type_var, value=&#34;spectator&#34;, command=self.handle_radio_click)
        self.spectator_radio.pack(side=&#34;left&#34;, padx=5, pady=5)

        self.player_type_frame.pack()

        # Logout and Exit buttons frame
        logout_exit_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
        logout_exit_frame.pack(side=&#34;bottom&#34;, fill=&#34;x&#34;)

        # Logout button
        logout_button = tk.Button(logout_exit_frame, text=&#34;Logout&#34;, width=10, font=(&#34;Arial&#34;, 12), bg=&#34;#FFC107&#34;, fg=&#34;white&#34;, relief=tk.FLAT, command=self.logout)
        logout_button.pack(side=&#34;left&#34;, padx=10, pady=10)

        # Exit button
        exit_button = tk.Button(logout_exit_frame, text=&#34;Exit&#34;, width=10, font=(&#34;Arial&#34;, 12), bg=&#34;#F44336&#34;, fg=&#34;white&#34;, relief=tk.FLAT, command=self.exit_app)
        exit_button.pack(side=&#34;right&#34;, padx=10, pady=10)

        # Hide the games list frame, players entry, and player type radio buttons initially
        self.games_list_frame.pack_forget()
        self.players_entry_frame.pack_forget()
        self.player_type_frame.pack_forget()

    
    def new_game(self):
        &#34;&#34;&#34;the user clicked on the &#39;New Game&#39; button
        &#34;&#34;&#34;
        self.games_list_frame.pack_forget()  # hide the listbox
        self.player_type_frame.pack_forget() # hide the player type frame
        if (self.new_game_button.cget(&#39;text&#39;) == &#34;New Game&#34;):
            self.players_entry_frame.pack()
            self.new_game_button.config(text=&#34;start!&#34;) # change the text of the button to &#39;start&#39;

        # the text of the button is &#39;start&#39;, which means that a text entry for number of players is already vidsible
        else:
            players_entry = self.players_entry.get()
            if (players_entry == &#34;&#34;  or  int(players_entry) &lt; 2  or  int(players_entry) &gt; 8):
                messagebox.showinfo(&#34;message&#34;, &#34;please insert a valid number of players (2-8 allowed)&#34;)
            else:
                self.controller.messageChannel.setRequest(&#34;newGame&#34;, int(players_entry)) # set a request for a new game

                t = threading.Thread(target=self.newGame_helper)
                t.start()
                # check periodically for a response from the server and handle a response in &#39;check_if_newGame_done&#39;
                schedule_check(self, t, self.check_if_newGame_done.__name__)


    def newGame_helper(self):
        &#34;&#34;&#34;check if a response from the server about the auth request has arrived.
            At first we check if the response is None i.e. no response has arrived, and then we verify
            that the response is what we expected to, i.e. &#34;response&#34; == &#34;2_newRegisteredGame&#34;, else we continue looping.
        &#34;&#34;&#34;
        while (self.controller.messageChannel.responses == []  or  
               self.controller.messageChannel.responses[0][&#34;response&#34;][0] != &#34;2&#34;):
            pass


    def check_if_newGame_done(self, t):
        &#34;&#34;&#34;if the thread &#39;t&#39; is dead then it means a response from the server about the auth request has arrived,
            the function handle that response
        Args:
            t (Thread): the thread that is in charge of checking if a newGame response has arrived
        &#34;&#34;&#34;
        if not t.is_alive():
            match self.controller.messageChannel.responses[0][&#34;response&#34;]: # examine the response headline
                # the request for a new game has granted
                case &#34;2_newRegisteredGame&#34;:
                    game = self.controller.messageChannel.responses[0][&#34;value&#34;] # should be a list [ game_ID, numOfPlayers ]
                    if self.controller.currentPage is MainPage:
                        self.controller.show_page(GamePage, game[1], game[0]) # move the the game page with two parameters: game_ID, num of players
                        # append a message to the player to the mesage queue
                        self.controller.currentPageInstance.message_buffer.append(f&#34;## waiting for {game[1]-1} more players to join and then we start!&#34;)
                case &#34;2_errorHasOccured&#34;:
                    messagebox.showinfo(&#34;message&#34;, &#34;an error has occured during a try to initiate a new game&#34;)
            # pop the handled response from the responses queue
            self.controller.messageChannel.responses.pop(0)

        else:
            # Otherwise check again after one second
            schedule_check(self, t, self.check_if_newGame_done.__name__)

    def join_game(self):
        &#34;&#34;&#34;a function to handle click on the &#39;join Game&#39; button
        &#34;&#34;&#34;
        # if the user clicked on the button of &#39;join&#39; after the &#39;New Game&#39; button was clicked once, retrieve the original text to the &#39;new game&#39; button
        self.new_game_button.config(text=&#34;New Game&#34;) 
        self.players_entry_frame.pack_forget()  # hide the &#39;number of players&#39; text entry that associated with a &#39;new game&#39; and not with a &#39;join game&#39; click
        self.games_list_frame.pack()            # show the list of open games
        
        self.join_game_button[&#34;state&#34;] = &#34;disabled&#34; # disable button until a response arrives
        
        self.controller.messageChannel.setRequest(&#34;fetchActiveGames&#34;, &#34;a&#34;) # send a request to fetch all active games from the server


        t = threading.Thread(target=self.fetchActiveGames_helper)
        t.start()
        # check periodically for a response from the server and handle a response in &#39;check_if_newGame_done&#39;
        schedule_check(self, t, self.check_if_fetchActiveGames_done.__name__)


    def fetchActiveGames_helper(self):
        &#34;&#34;&#34;check if a response from the server about &#39;fetching the games&#39; request has arrived.
            At first we check if the response is None i.e. no response has arrived, and then we verify
            that the response is what we expected to, i.e. &#34;response&#34; == &#34;3_allActiveGames&#34;, else we continue looping.
        &#34;&#34;&#34;
        while (self.controller.messageChannel.responses == []  or  
               self.controller.messageChannel.responses[0][&#34;response&#34;][0] != &#34;3&#34;):
            pass


    def check_if_fetchActiveGames_done(self, t):
        &#34;&#34;&#34;if the thread &#39;t&#39; is dead then it means a response from the server about the auth request has arrived,
            the function handle that response
        Args:
            t (Thread): the thread that is in charge of checking if a fetchActiveGames response has arrived
        &#34;&#34;&#34;
        if not t.is_alive():
            self.games_listbox.delete(0,&#34;end&#34;) # clear the list of games before populating it
            self.activeGames_initialized = []
            self.activeGames_occuring = []

            games = self.controller.messageChannel.responses[0][&#34;value&#34;]
            for key, game in games.items():
                # we get the following format: key = gameID, game = ({Game as dict}, number of active participants, number of passive participants - spectators)
                if (game[0][&#34;game_state&#34;] == &#34;INITIALIZED&#34;):
                    self.activeGames_initialized.append(game)
                elif (game[0][&#34;game_state&#34;] == &#34;STARTED&#34;):
                    self.activeGames_occuring.append(game)

            # building the list of games for displaying it to the user
            for index, game in enumerate(self.activeGames_initialized):
                strForDisplay = f&#34;Game {index+1} (opened for &#34; + str(game[0][&#34;num_of_players&#34;]) + &#34; players, waiting for &#34; + str(game[0][&#34;num_of_players&#34;]-game[1]) + &#34; more, &#34; + str(game[2]) + &#34; spectators&#34; + &#34;)&#34;
                self.games_listbox.insert(&#34;end&#34;, strForDisplay)
            
            self.player_type_frame.pack()               # display two option for the user: spectator or player
            self.join_game_button[&#34;state&#34;] = &#34;normal&#34;   # make the button clickable

            # pop the resposne from the queue of responses
            self.controller.messageChannel.responses.pop(0)
      
        else:
            # Otherwise check again after one second
            schedule_check(self, t, self.check_if_fetchActiveGames_done.__name__)


    def handle_radio_click(self):
        &#34;&#34;&#34;handle clicking on one of the radio buttons: spectator or player
        &#34;&#34;&#34;
        player_type = self.player_type_var.get()
        print(f&#34;Selected player type: {player_type}&#34;)
        if (player_type != self.player_last_type): # handke click only if it is differnet from the last click (because the user can click on the same button more than once)
            if player_type == &#34;active_player&#34; and self.activeGames_occuring != []:
                # delete the items repreenting occurring games, whom the player can&#39;t join
                self.games_listbox.delete(len(self.activeGames_initialized),len(self.activeGames_initialized)+len(self.activeGames_occuring)-1)
            elif player_type == &#34;spectator&#34;:
                # add the occurring games, because as a spectator the user can join either a game that has not yet started or an already started gamnes
                for index, game in enumerate(self.activeGames_occuring):
                    strForDisplay = f&#34;Game {len(self.activeGames_initialized)+index+1} (opened for &#34; + str(game[0][&#34;num_of_players&#34;]) + &#34; players, waiting for &#34; + str(game[0][&#34;num_of_players&#34;]-game[1]) + &#34; more, &#34; + str(game[2]) + &#34; spectators&#34; + &#34;)&#34;
                    self.games_listbox.insert(&#34;end&#34;, strForDisplay)

        self.player_last_type = player_type


    def on_game_select(self, event):
        &#34;&#34;&#34;handle clikcing on a game entry in the box list for joining

        Args:
            event: which event happened (defined for double-click only)
        &#34;&#34;&#34;
        selected_index = self.games_listbox.curselection()[0]

        # the user is a spectator in an occurring game
        if (selected_index &gt;= len(self.activeGames_initialized)): 
            selectedGame = self.activeGames_occuring[selected_index-len(self.activeGames_initialized)][0]
            self.controller.show_page(GamePage, selectedGame[&#34;num_of_players&#34;], selectedGame[&#34;game_ID&#34;], selectedGame[&#34;board&#34;], True)

        # the user is either an active player or a spectator in a game that has not yet started
        else:
            selectedGame = self.activeGames_initialized[selected_index][0]
            if self.player_type_var.get() == &#34;spectator&#34;:
                self.controller.show_page(GamePage, selectedGame[&#34;num_of_players&#34;], selectedGame[&#34;game_ID&#34;], &#34;&#34;, True)
            else:
                self.controller.show_page(GamePage, selectedGame[&#34;num_of_players&#34;], selectedGame[&#34;game_ID&#34;])
             

        # send a message to the server that a new player has now joined the game
        if self.player_type_var.get() == &#34;active_player&#34;:
            self.controller.messageChannel.setRequest(&#34;newJoined&#34;, (&#34;player&#34;, selectedGame[&#34;game_ID&#34;]))
        
        # self.player_type_var.get() == &#34;spectator&#34;
        else:
            self.controller.currentPageInstance.spectator_label.pack()
            self.controller.messageChannel.setRequest(&#34;newJoined&#34;, (&#34;spectator&#34;, selectedGame[&#34;game_ID&#34;]))


    def logout(self):
        &#34;&#34;&#34;handle clicking in the &#39;logout&#39; button
        &#34;&#34;&#34;
        self.controller.messageChannel.setRequest(&#34;logout&#34;, &#34;a&#34;) # send a request to log out
        self.controller.show_page(AuthPageToken)                 # move back to the authentication page

    def exit_app(self):
        &#34;&#34;&#34;upon clicking the &#39;exit&#39; button, handle exiting the game gracefully by sending a message
            to the server
        &#34;&#34;&#34;
        self.controller.messageChannel.setRequest(&#34;exit&#34;, &#34;a&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Presentation.MainPage.check_if_fetchActiveGames_done"><code class="name flex">
<span>def <span class="ident">check_if_fetchActiveGames_done</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"><p>if the thread 't' is dead then it means a response from the server about the auth request has arrived,
the function handle that response</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>Thread</code></dt>
<dd>the thread that is in charge of checking if a fetchActiveGames response has arrived</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_if_fetchActiveGames_done(self, t):
    &#34;&#34;&#34;if the thread &#39;t&#39; is dead then it means a response from the server about the auth request has arrived,
        the function handle that response
    Args:
        t (Thread): the thread that is in charge of checking if a fetchActiveGames response has arrived
    &#34;&#34;&#34;
    if not t.is_alive():
        self.games_listbox.delete(0,&#34;end&#34;) # clear the list of games before populating it
        self.activeGames_initialized = []
        self.activeGames_occuring = []

        games = self.controller.messageChannel.responses[0][&#34;value&#34;]
        for key, game in games.items():
            # we get the following format: key = gameID, game = ({Game as dict}, number of active participants, number of passive participants - spectators)
            if (game[0][&#34;game_state&#34;] == &#34;INITIALIZED&#34;):
                self.activeGames_initialized.append(game)
            elif (game[0][&#34;game_state&#34;] == &#34;STARTED&#34;):
                self.activeGames_occuring.append(game)

        # building the list of games for displaying it to the user
        for index, game in enumerate(self.activeGames_initialized):
            strForDisplay = f&#34;Game {index+1} (opened for &#34; + str(game[0][&#34;num_of_players&#34;]) + &#34; players, waiting for &#34; + str(game[0][&#34;num_of_players&#34;]-game[1]) + &#34; more, &#34; + str(game[2]) + &#34; spectators&#34; + &#34;)&#34;
            self.games_listbox.insert(&#34;end&#34;, strForDisplay)
        
        self.player_type_frame.pack()               # display two option for the user: spectator or player
        self.join_game_button[&#34;state&#34;] = &#34;normal&#34;   # make the button clickable

        # pop the resposne from the queue of responses
        self.controller.messageChannel.responses.pop(0)
  
    else:
        # Otherwise check again after one second
        schedule_check(self, t, self.check_if_fetchActiveGames_done.__name__)</code></pre>
</details>
</dd>
<dt id="Presentation.MainPage.check_if_newGame_done"><code class="name flex">
<span>def <span class="ident">check_if_newGame_done</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"><p>if the thread 't' is dead then it means a response from the server about the auth request has arrived,
the function handle that response</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>Thread</code></dt>
<dd>the thread that is in charge of checking if a newGame response has arrived</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_if_newGame_done(self, t):
    &#34;&#34;&#34;if the thread &#39;t&#39; is dead then it means a response from the server about the auth request has arrived,
        the function handle that response
    Args:
        t (Thread): the thread that is in charge of checking if a newGame response has arrived
    &#34;&#34;&#34;
    if not t.is_alive():
        match self.controller.messageChannel.responses[0][&#34;response&#34;]: # examine the response headline
            # the request for a new game has granted
            case &#34;2_newRegisteredGame&#34;:
                game = self.controller.messageChannel.responses[0][&#34;value&#34;] # should be a list [ game_ID, numOfPlayers ]
                if self.controller.currentPage is MainPage:
                    self.controller.show_page(GamePage, game[1], game[0]) # move the the game page with two parameters: game_ID, num of players
                    # append a message to the player to the mesage queue
                    self.controller.currentPageInstance.message_buffer.append(f&#34;## waiting for {game[1]-1} more players to join and then we start!&#34;)
            case &#34;2_errorHasOccured&#34;:
                messagebox.showinfo(&#34;message&#34;, &#34;an error has occured during a try to initiate a new game&#34;)
        # pop the handled response from the responses queue
        self.controller.messageChannel.responses.pop(0)

    else:
        # Otherwise check again after one second
        schedule_check(self, t, self.check_if_newGame_done.__name__)</code></pre>
</details>
</dd>
<dt id="Presentation.MainPage.create_widgets"><code class="name flex">
<span>def <span class="ident">create_widgets</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>create the graphical elements and define their properties</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_widgets(self):
    &#34;&#34;&#34;create the graphical elements and define their properties
    &#34;&#34;&#34;
    # Headline label
    headline_label = tk.Label(self, text=&#34;Game Center&#34;, font=(&#34;Verdana&#34;, 24, &#34;bold&#34;), bg=&#34;#f0f0f0&#34;)
    headline_label.pack(pady=10)

    # Buttons frame
    self.buttons_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
    self.buttons_frame.pack()

    # New Game button
    self.new_game_button = tk.Button(self.buttons_frame, text=&#34;New Game&#34;, width=15, font=(&#34;Verdana&#34;, 12), bg=&#34;#4CAF50&#34;, fg=&#34;white&#34;, relief=tk.FLAT, command=self.new_game)
    self.new_game_button.grid(row=0, column=0, padx=10)

    # Join a Game button
    self.join_game_button = tk.Button(self.buttons_frame, text=&#34;Join a Game&#34;, width=15, font=(&#34;Arial&#34;, 12), bg=&#34;#FFC107&#34;, fg=&#34;white&#34;, relief=tk.FLAT, command=self.join_game)
    self.join_game_button.grid(row=0, column=1, padx=10)

    # View Leadership Games button
    view_games_button = tk.Button(self.buttons_frame, text=&#34;View Leadership Games&#34;, width=20, font=(&#34;Arial&#34;, 12), bg=&#34;#2196F3&#34;, fg=&#34;white&#34;, relief=tk.FLAT, command=lambda: self.controller.show_page(StatisticsPage))
    view_games_button.grid(row=0, column=2, padx=10)

    # Games list frame (initially hidden)
    self.games_list_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
    self.games_list_frame.pack()

    # Listbox for games
    self.games_listbox = tk.Listbox(self.games_list_frame, width=50, height=10, font=(&#34;Arial&#34;, 12), bg=&#34;white&#34;, selectbackground=&#34;#FFC107&#34;)
    self.games_listbox.pack(side=&#34;left&#34;, fill=&#34;y&#34;, padx=5, pady=5)
    
    # Bind callback function to listbox selection event
    self.games_listbox.bind(&#34;&lt;Double-Button-1&gt;&#34;, self.on_game_select)
    
    # Scrollbar for listbox
    scrollbar = tk.Scrollbar(self.games_list_frame, orient=&#34;vertical&#34;, command=self.games_listbox.yview)
    scrollbar.pack(side=&#34;right&#34;, fill=&#34;y&#34;)

    # Configure listbox to use scrollbar
    self.games_listbox.config(yscrollcommand=scrollbar.set)


    self.activeGames_initialized = []
    self.activeGames_occuring = []

    # Text entry for number of players (initially hidden)
    self.players_entry_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
    self.players_entry_label = tk.Label(self.players_entry_frame, text=&#34;Number of Players:&#34;, font=(&#34;Verdana&#34;, 12), bg=&#34;#f0f0f0&#34;)
    self.players_entry_label.pack(side=&#34;left&#34;, padx=5, pady=5)
    self.players_entry = tk.Entry(self.players_entry_frame, font=(&#34;Arial&#34;, 12), width=10, justify=&#39;center&#39;)
    self.players_entry.pack(side=&#34;left&#34;, padx=5, pady=5)
    self.players_entry_frame.pack()

    # Radio buttons for player type (initially hidden)
    self.player_type_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
    self.player_type_label = tk.Label(self.player_type_frame, text=&#34;Player Type:&#34;, font=(&#34;Arial&#34;, 12), bg=&#34;#f0f0f0&#34;)
    self.player_type_label.pack(side=&#34;left&#34;, padx=5, pady=5)

    self.player_type_var = tk.StringVar(value=&#34;active_player&#34;)
    self.player_last_type = &#34;active_player&#34; # used to verify that the user changed the radio button selection
                                            # and not just clicked on the same button

    style = ttk.Style()
    style.configure(&#34;TRadiobutton&#34;, background=&#34;#f0f0f0&#34;, font=(&#34;Arial&#34;, 12))

    self.active_player_radio = ttk.Radiobutton(self.player_type_frame, text=&#34;Active Player&#34;, variable=self.player_type_var, value=&#34;active_player&#34;, command=self.handle_radio_click)
    self.active_player_radio.pack(side=&#34;left&#34;, padx=5, pady=5)

    self.spectator_radio = ttk.Radiobutton(self.player_type_frame, text=&#34;Spectator&#34;, variable=self.player_type_var, value=&#34;spectator&#34;, command=self.handle_radio_click)
    self.spectator_radio.pack(side=&#34;left&#34;, padx=5, pady=5)

    self.player_type_frame.pack()

    # Logout and Exit buttons frame
    logout_exit_frame = tk.Frame(self, bg=&#34;#f0f0f0&#34;)
    logout_exit_frame.pack(side=&#34;bottom&#34;, fill=&#34;x&#34;)

    # Logout button
    logout_button = tk.Button(logout_exit_frame, text=&#34;Logout&#34;, width=10, font=(&#34;Arial&#34;, 12), bg=&#34;#FFC107&#34;, fg=&#34;white&#34;, relief=tk.FLAT, command=self.logout)
    logout_button.pack(side=&#34;left&#34;, padx=10, pady=10)

    # Exit button
    exit_button = tk.Button(logout_exit_frame, text=&#34;Exit&#34;, width=10, font=(&#34;Arial&#34;, 12), bg=&#34;#F44336&#34;, fg=&#34;white&#34;, relief=tk.FLAT, command=self.exit_app)
    exit_button.pack(side=&#34;right&#34;, padx=10, pady=10)

    # Hide the games list frame, players entry, and player type radio buttons initially
    self.games_list_frame.pack_forget()
    self.players_entry_frame.pack_forget()
    self.player_type_frame.pack_forget()</code></pre>
</details>
</dd>
<dt id="Presentation.MainPage.exit_app"><code class="name flex">
<span>def <span class="ident">exit_app</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>upon clicking the 'exit' button, handle exiting the game gracefully by sending a message
to the server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exit_app(self):
    &#34;&#34;&#34;upon clicking the &#39;exit&#39; button, handle exiting the game gracefully by sending a message
        to the server
    &#34;&#34;&#34;
    self.controller.messageChannel.setRequest(&#34;exit&#34;, &#34;a&#34;)</code></pre>
</details>
</dd>
<dt id="Presentation.MainPage.fetchActiveGames_helper"><code class="name flex">
<span>def <span class="ident">fetchActiveGames_helper</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>check if a response from the server about 'fetching the games' request has arrived.
At first we check if the response is None i.e. no response has arrived, and then we verify
that the response is what we expected to, i.e. "response" == "3_allActiveGames", else we continue looping.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetchActiveGames_helper(self):
    &#34;&#34;&#34;check if a response from the server about &#39;fetching the games&#39; request has arrived.
        At first we check if the response is None i.e. no response has arrived, and then we verify
        that the response is what we expected to, i.e. &#34;response&#34; == &#34;3_allActiveGames&#34;, else we continue looping.
    &#34;&#34;&#34;
    while (self.controller.messageChannel.responses == []  or  
           self.controller.messageChannel.responses[0][&#34;response&#34;][0] != &#34;3&#34;):
        pass</code></pre>
</details>
</dd>
<dt id="Presentation.MainPage.handle_radio_click"><code class="name flex">
<span>def <span class="ident">handle_radio_click</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>handle clicking on one of the radio buttons: spectator or player</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_radio_click(self):
    &#34;&#34;&#34;handle clicking on one of the radio buttons: spectator or player
    &#34;&#34;&#34;
    player_type = self.player_type_var.get()
    print(f&#34;Selected player type: {player_type}&#34;)
    if (player_type != self.player_last_type): # handke click only if it is differnet from the last click (because the user can click on the same button more than once)
        if player_type == &#34;active_player&#34; and self.activeGames_occuring != []:
            # delete the items repreenting occurring games, whom the player can&#39;t join
            self.games_listbox.delete(len(self.activeGames_initialized),len(self.activeGames_initialized)+len(self.activeGames_occuring)-1)
        elif player_type == &#34;spectator&#34;:
            # add the occurring games, because as a spectator the user can join either a game that has not yet started or an already started gamnes
            for index, game in enumerate(self.activeGames_occuring):
                strForDisplay = f&#34;Game {len(self.activeGames_initialized)+index+1} (opened for &#34; + str(game[0][&#34;num_of_players&#34;]) + &#34; players, waiting for &#34; + str(game[0][&#34;num_of_players&#34;]-game[1]) + &#34; more, &#34; + str(game[2]) + &#34; spectators&#34; + &#34;)&#34;
                self.games_listbox.insert(&#34;end&#34;, strForDisplay)

    self.player_last_type = player_type</code></pre>
</details>
</dd>
<dt id="Presentation.MainPage.join_game"><code class="name flex">
<span>def <span class="ident">join_game</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>a function to handle click on the 'join Game' button</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join_game(self):
    &#34;&#34;&#34;a function to handle click on the &#39;join Game&#39; button
    &#34;&#34;&#34;
    # if the user clicked on the button of &#39;join&#39; after the &#39;New Game&#39; button was clicked once, retrieve the original text to the &#39;new game&#39; button
    self.new_game_button.config(text=&#34;New Game&#34;) 
    self.players_entry_frame.pack_forget()  # hide the &#39;number of players&#39; text entry that associated with a &#39;new game&#39; and not with a &#39;join game&#39; click
    self.games_list_frame.pack()            # show the list of open games
    
    self.join_game_button[&#34;state&#34;] = &#34;disabled&#34; # disable button until a response arrives
    
    self.controller.messageChannel.setRequest(&#34;fetchActiveGames&#34;, &#34;a&#34;) # send a request to fetch all active games from the server


    t = threading.Thread(target=self.fetchActiveGames_helper)
    t.start()
    # check periodically for a response from the server and handle a response in &#39;check_if_newGame_done&#39;
    schedule_check(self, t, self.check_if_fetchActiveGames_done.__name__)</code></pre>
</details>
</dd>
<dt id="Presentation.MainPage.logout"><code class="name flex">
<span>def <span class="ident">logout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>handle clicking in the 'logout' button</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logout(self):
    &#34;&#34;&#34;handle clicking in the &#39;logout&#39; button
    &#34;&#34;&#34;
    self.controller.messageChannel.setRequest(&#34;logout&#34;, &#34;a&#34;) # send a request to log out
    self.controller.show_page(AuthPageToken)                 # move back to the authentication page</code></pre>
</details>
</dd>
<dt id="Presentation.MainPage.newGame_helper"><code class="name flex">
<span>def <span class="ident">newGame_helper</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>check if a response from the server about the auth request has arrived.
At first we check if the response is None i.e. no response has arrived, and then we verify
that the response is what we expected to, i.e. "response" == "2_newRegisteredGame", else we continue looping.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newGame_helper(self):
    &#34;&#34;&#34;check if a response from the server about the auth request has arrived.
        At first we check if the response is None i.e. no response has arrived, and then we verify
        that the response is what we expected to, i.e. &#34;response&#34; == &#34;2_newRegisteredGame&#34;, else we continue looping.
    &#34;&#34;&#34;
    while (self.controller.messageChannel.responses == []  or  
           self.controller.messageChannel.responses[0][&#34;response&#34;][0] != &#34;2&#34;):
        pass</code></pre>
</details>
</dd>
<dt id="Presentation.MainPage.new_game"><code class="name flex">
<span>def <span class="ident">new_game</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>the user clicked on the 'New Game' button</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_game(self):
    &#34;&#34;&#34;the user clicked on the &#39;New Game&#39; button
    &#34;&#34;&#34;
    self.games_list_frame.pack_forget()  # hide the listbox
    self.player_type_frame.pack_forget() # hide the player type frame
    if (self.new_game_button.cget(&#39;text&#39;) == &#34;New Game&#34;):
        self.players_entry_frame.pack()
        self.new_game_button.config(text=&#34;start!&#34;) # change the text of the button to &#39;start&#39;

    # the text of the button is &#39;start&#39;, which means that a text entry for number of players is already vidsible
    else:
        players_entry = self.players_entry.get()
        if (players_entry == &#34;&#34;  or  int(players_entry) &lt; 2  or  int(players_entry) &gt; 8):
            messagebox.showinfo(&#34;message&#34;, &#34;please insert a valid number of players (2-8 allowed)&#34;)
        else:
            self.controller.messageChannel.setRequest(&#34;newGame&#34;, int(players_entry)) # set a request for a new game

            t = threading.Thread(target=self.newGame_helper)
            t.start()
            # check periodically for a response from the server and handle a response in &#39;check_if_newGame_done&#39;
            schedule_check(self, t, self.check_if_newGame_done.__name__)</code></pre>
</details>
</dd>
<dt id="Presentation.MainPage.on_game_select"><code class="name flex">
<span>def <span class="ident">on_game_select</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>handle clikcing on a game entry in the box list for joining</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong></dt>
<dd>which event happened (defined for double-click only)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_game_select(self, event):
    &#34;&#34;&#34;handle clikcing on a game entry in the box list for joining

    Args:
        event: which event happened (defined for double-click only)
    &#34;&#34;&#34;
    selected_index = self.games_listbox.curselection()[0]

    # the user is a spectator in an occurring game
    if (selected_index &gt;= len(self.activeGames_initialized)): 
        selectedGame = self.activeGames_occuring[selected_index-len(self.activeGames_initialized)][0]
        self.controller.show_page(GamePage, selectedGame[&#34;num_of_players&#34;], selectedGame[&#34;game_ID&#34;], selectedGame[&#34;board&#34;], True)

    # the user is either an active player or a spectator in a game that has not yet started
    else:
        selectedGame = self.activeGames_initialized[selected_index][0]
        if self.player_type_var.get() == &#34;spectator&#34;:
            self.controller.show_page(GamePage, selectedGame[&#34;num_of_players&#34;], selectedGame[&#34;game_ID&#34;], &#34;&#34;, True)
        else:
            self.controller.show_page(GamePage, selectedGame[&#34;num_of_players&#34;], selectedGame[&#34;game_ID&#34;])
         

    # send a message to the server that a new player has now joined the game
    if self.player_type_var.get() == &#34;active_player&#34;:
        self.controller.messageChannel.setRequest(&#34;newJoined&#34;, (&#34;player&#34;, selectedGame[&#34;game_ID&#34;]))
    
    # self.player_type_var.get() == &#34;spectator&#34;
    else:
        self.controller.currentPageInstance.spectator_label.pack()
        self.controller.messageChannel.setRequest(&#34;newJoined&#34;, (&#34;spectator&#34;, selectedGame[&#34;game_ID&#34;]))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Presentation.SignUpPage"><code class="flex name class">
<span>class <span class="ident">SignUpPage</span></span>
<span>(</span><span>parent, controller)</span>
</code></dt>
<dd>
<div class="desc"><p>Page for registering new user to the system</p>
<p>constructor for SignUpPage</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>tk.Frame</code></dt>
<dd>a frame that inherits from the app root</dd>
<dt><strong><code>controller</code></strong> :&ensp;<code>AppRoot</code></dt>
<dd>the controller of the app</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SignUpPage(tk.Frame):
    &#34;&#34;&#34;Page for registering new user to the system
    &#34;&#34;&#34;
    def __init__(self, parent, controller):
        &#34;&#34;&#34;constructor for SignUpPage

        Args:
            parent (tk.Frame): a frame that inherits from the app root
            controller (AppRoot): the controller of the app
        &#34;&#34;&#34;
        tk.Frame.__init__(self, parent)

        self.parent = parent
        self.controller = controller

        self.create_widgets()  # call the function that create the graphical elements

    def create_widgets(self):
        &#34;&#34;&#34;create the graphical elements and define their properties
        &#34;&#34;&#34;
        # Create headline
        headline_label = ttk.Label(self, text=&#34;Tic Tac Toe&#34;, font=LARGEFONT, background=&#39;#F0F0F0&#39;, foreground=&#39;#333333&#39;)
        headline_label.pack(pady=10)

        # Group auth objects 
        detailsFrame = tk.Frame(self, bg=&#34;#F0F0F0&#34;, highlightbackground=&#34;#F0F0F0&#34;, highlightthickness=0)
        detailsFrame.place(relx=0.5, rely=0.5, anchor=&#34;center&#34;)
        
        # Choose nikname
        nikName_label = ttk.Label(detailsFrame, text=&#34;Enter Your Nik Name: &#34;, font=MEDIUMFONT, background=&#39;#F0F0F0&#39;, foreground=&#39;#333333&#39;)
        nikName_label.grid(row=0, column=0, pady=(0, 20), sticky=&#34;e&#34;)
        self.nikName_entry = tk.Entry(detailsFrame, font=(&#34;Verdana&#34;, 18))
        self.nikName_entry.grid(row=0, column=1, pady=(0, 20), sticky=&#34;w&#34;)
        self.nikName_entry.focus_set()

        # &#39;Create User&#39; button
        self.createUser_button = tk.Button(detailsFrame, text=&#34;Create New User&#34;, command=self.createUser, font=(&#34;Verdana&#34;, 18), bg=&#39;#4CAF50&#39;, fg=&#39;white&#39;)
        self.createUser_button.grid(row=1, column=0, columnspan=2, pady=(20, 50), sticky=&#34;n&#34;)

        # &#39;New Token&#39; label
        self.token_label1 = ttk.Label(detailsFrame, text=&#34;Your unique token is:&#34;, font=MEDIUMFONT, background=&#39;#F0F0F0&#39;, foreground=&#39;#333333&#39;)
        self.token_label1.grid(row=2, column=0, columnspan=2, pady=(20, 50), sticky=&#34;w&#34;)
        self.token_label1.grid_forget()
        
        # actual token label
        self.token_label2 = ttk.Label(detailsFrame, text=&#34;_______&#34;, font=MEDIUMFONT, background=&#39;#F0F0F0&#39;, foreground=&#39;#333333&#39;)
        self.token_label2.grid(row=2, column=1, columnspan=2, pady=(20, 50), sticky=&#34;w&#34;)
        self.token_label2.grid_forget()


        # Create Exit button
        exit_button = tk.Button(self, text=&#34; Exit &#34;, command=self.exitTheGame, font=(&#34;Verdana&#34;, 18), bg=&#39;#4CAF50&#39;, fg=&#39;white&#39;)
        exit_button.place(relx=0.6, rely=0.9)

        
        # Create Sign In button
        signIn_button = tk.Button(self, text=&#34;Sign In&#34;, command=lambda: self.controller.show_page(AuthPageToken), font=(&#34;Verdana&#34;, 18), bg=&#39;#4CAF50&#39;, fg=&#39;white&#39;)
        signIn_button.place(relx=0.3, rely=0.9)


    def createUser(self):
        &#34;&#34;&#34;create new user by generating unique token and binding the chosen nik name to it
        &#34;&#34;&#34;
        # force the user to choose a nik name
        if self.nikName_entry.get() == &#34;&#34;: 
                messagebox.showinfo(&#34;nik name missing&#34;, &#34;You have to insert a NikName!&#34;)

        else:
            # first click on the button. If the request is granted then the text will be changed to &#39;start&#39;
            if self.createUser_button.cget(&#39;text&#39;) ==  &#34;Create New User&#34;: 
                self.createUser_button[&#34;state&#34;] = &#34;disabled&#34;                  # disable the button until we get a response from the server
                nikName = self.nikName_entry.get()                            # get the nik name the user chose
                self.controller.messageChannel.setRequest(&#34;newUser&#34;, nikName) # send a request of &#39;newUser&#39; to the server
                
                t = threading.Thread(target=self.signUp_helper)
                t.start()
                # check periodically for a response from the server and handle a response in &#39;check_if_signUp_done&#39;
                schedule_check(self, t, self.check_if_signUp_done.__name__)


            # click on the button when its text is &#39;start&#39; (second click), continue to the Main page
            else:
                self.controller.show_page(MainPage)

        
    def signUp_helper(self):
        &#34;&#34;&#34;check if a response from the server about the signUp request has arrived.
            At first we check if the response is None i.e. no response has arrived, and then we verify
            that the response is what we expected to, i.e. &#34;response&#34; == &#34;1_newUser&#34;, else we continue looping.
        &#34;&#34;&#34;
        while (self.controller.messageChannel.responses == []  or  
               self.controller.messageChannel.responses[0][&#34;response&#34;][0] != &#34;1&#34;):
            pass


    def check_if_signUp_done(self, t):
        &#34;&#34;&#34;if the thread &#39;t&#39; is dead then it means a response from the server about the auth request has arrived,
            the function handle that response
        Args:
            t (Thread): the thread that is in charge of checking if a signUp response has arrived
        &#34;&#34;&#34;
        # If the thread has finished, re-enable the button and show a message.
        if not t.is_alive():
            self.createUser_button.config(text=&#34;continue&#34;)
            self.createUser_button[&#34;state&#34;] = &#34;normal&#34; # a resposne has arrived so enable the button

            match self.controller.messageChannel.responses[0][&#34;response&#34;]: # examine the response
                # a request for a new user has granted
                case &#34;1_newUser&#34;:
                    if self.controller.currentPage is SignUpPage:
                        self.token_label1.config(text=&#34;Your unique token is &#34; + str(self.controller.messageChannel.responses[0][&#34;value&#34;]))
                        self.token_label1.grid(row=2, column=0, columnspan=2, pady=(20, 50), sticky=&#34;w&#34;)
                # an error has occurred
                case &#34;1_errorHasOccured&#34;:
                        self.token_label1.config(text=&#34;error has occured, try again&#34;)
                        self.token_label1.grid(row=2, column=0, columnspan=2, pady=(20, 50), sticky=&#34;w&#34;)  
            
            # pop the response from the queue of responses
            self.controller.messageChannel.responses.pop(0)
      
        else:
            # Otherwise check again after one second
            schedule_check(self, t, self.check_if_signUp_done.__name__)


    def getNikNameEntry(self):
        &#34;&#34;&#34;get the text in the &#39;insert token&#39; entry

        Returns:
            str: token, unique ID of the user
        &#34;&#34;&#34;
        return self.nikName_entry.get()
    

    def exitTheGame(self):
        &#34;&#34;&#34;upon clicking the &#39;exit&#39; button, handle exiting the game gracefully by sending a message
            to the server
        &#34;&#34;&#34;
        self.controller.messageChannel.setRequest(&#34;exit&#34;, &#34;a&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Presentation.SignUpPage.check_if_signUp_done"><code class="name flex">
<span>def <span class="ident">check_if_signUp_done</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"><p>if the thread 't' is dead then it means a response from the server about the auth request has arrived,
the function handle that response</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>Thread</code></dt>
<dd>the thread that is in charge of checking if a signUp response has arrived</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_if_signUp_done(self, t):
    &#34;&#34;&#34;if the thread &#39;t&#39; is dead then it means a response from the server about the auth request has arrived,
        the function handle that response
    Args:
        t (Thread): the thread that is in charge of checking if a signUp response has arrived
    &#34;&#34;&#34;
    # If the thread has finished, re-enable the button and show a message.
    if not t.is_alive():
        self.createUser_button.config(text=&#34;continue&#34;)
        self.createUser_button[&#34;state&#34;] = &#34;normal&#34; # a resposne has arrived so enable the button

        match self.controller.messageChannel.responses[0][&#34;response&#34;]: # examine the response
            # a request for a new user has granted
            case &#34;1_newUser&#34;:
                if self.controller.currentPage is SignUpPage:
                    self.token_label1.config(text=&#34;Your unique token is &#34; + str(self.controller.messageChannel.responses[0][&#34;value&#34;]))
                    self.token_label1.grid(row=2, column=0, columnspan=2, pady=(20, 50), sticky=&#34;w&#34;)
            # an error has occurred
            case &#34;1_errorHasOccured&#34;:
                    self.token_label1.config(text=&#34;error has occured, try again&#34;)
                    self.token_label1.grid(row=2, column=0, columnspan=2, pady=(20, 50), sticky=&#34;w&#34;)  
        
        # pop the response from the queue of responses
        self.controller.messageChannel.responses.pop(0)
  
    else:
        # Otherwise check again after one second
        schedule_check(self, t, self.check_if_signUp_done.__name__)</code></pre>
</details>
</dd>
<dt id="Presentation.SignUpPage.createUser"><code class="name flex">
<span>def <span class="ident">createUser</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>create new user by generating unique token and binding the chosen nik name to it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createUser(self):
    &#34;&#34;&#34;create new user by generating unique token and binding the chosen nik name to it
    &#34;&#34;&#34;
    # force the user to choose a nik name
    if self.nikName_entry.get() == &#34;&#34;: 
            messagebox.showinfo(&#34;nik name missing&#34;, &#34;You have to insert a NikName!&#34;)

    else:
        # first click on the button. If the request is granted then the text will be changed to &#39;start&#39;
        if self.createUser_button.cget(&#39;text&#39;) ==  &#34;Create New User&#34;: 
            self.createUser_button[&#34;state&#34;] = &#34;disabled&#34;                  # disable the button until we get a response from the server
            nikName = self.nikName_entry.get()                            # get the nik name the user chose
            self.controller.messageChannel.setRequest(&#34;newUser&#34;, nikName) # send a request of &#39;newUser&#39; to the server
            
            t = threading.Thread(target=self.signUp_helper)
            t.start()
            # check periodically for a response from the server and handle a response in &#39;check_if_signUp_done&#39;
            schedule_check(self, t, self.check_if_signUp_done.__name__)


        # click on the button when its text is &#39;start&#39; (second click), continue to the Main page
        else:
            self.controller.show_page(MainPage)</code></pre>
</details>
</dd>
<dt id="Presentation.SignUpPage.create_widgets"><code class="name flex">
<span>def <span class="ident">create_widgets</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>create the graphical elements and define their properties</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_widgets(self):
    &#34;&#34;&#34;create the graphical elements and define their properties
    &#34;&#34;&#34;
    # Create headline
    headline_label = ttk.Label(self, text=&#34;Tic Tac Toe&#34;, font=LARGEFONT, background=&#39;#F0F0F0&#39;, foreground=&#39;#333333&#39;)
    headline_label.pack(pady=10)

    # Group auth objects 
    detailsFrame = tk.Frame(self, bg=&#34;#F0F0F0&#34;, highlightbackground=&#34;#F0F0F0&#34;, highlightthickness=0)
    detailsFrame.place(relx=0.5, rely=0.5, anchor=&#34;center&#34;)
    
    # Choose nikname
    nikName_label = ttk.Label(detailsFrame, text=&#34;Enter Your Nik Name: &#34;, font=MEDIUMFONT, background=&#39;#F0F0F0&#39;, foreground=&#39;#333333&#39;)
    nikName_label.grid(row=0, column=0, pady=(0, 20), sticky=&#34;e&#34;)
    self.nikName_entry = tk.Entry(detailsFrame, font=(&#34;Verdana&#34;, 18))
    self.nikName_entry.grid(row=0, column=1, pady=(0, 20), sticky=&#34;w&#34;)
    self.nikName_entry.focus_set()

    # &#39;Create User&#39; button
    self.createUser_button = tk.Button(detailsFrame, text=&#34;Create New User&#34;, command=self.createUser, font=(&#34;Verdana&#34;, 18), bg=&#39;#4CAF50&#39;, fg=&#39;white&#39;)
    self.createUser_button.grid(row=1, column=0, columnspan=2, pady=(20, 50), sticky=&#34;n&#34;)

    # &#39;New Token&#39; label
    self.token_label1 = ttk.Label(detailsFrame, text=&#34;Your unique token is:&#34;, font=MEDIUMFONT, background=&#39;#F0F0F0&#39;, foreground=&#39;#333333&#39;)
    self.token_label1.grid(row=2, column=0, columnspan=2, pady=(20, 50), sticky=&#34;w&#34;)
    self.token_label1.grid_forget()
    
    # actual token label
    self.token_label2 = ttk.Label(detailsFrame, text=&#34;_______&#34;, font=MEDIUMFONT, background=&#39;#F0F0F0&#39;, foreground=&#39;#333333&#39;)
    self.token_label2.grid(row=2, column=1, columnspan=2, pady=(20, 50), sticky=&#34;w&#34;)
    self.token_label2.grid_forget()


    # Create Exit button
    exit_button = tk.Button(self, text=&#34; Exit &#34;, command=self.exitTheGame, font=(&#34;Verdana&#34;, 18), bg=&#39;#4CAF50&#39;, fg=&#39;white&#39;)
    exit_button.place(relx=0.6, rely=0.9)

    
    # Create Sign In button
    signIn_button = tk.Button(self, text=&#34;Sign In&#34;, command=lambda: self.controller.show_page(AuthPageToken), font=(&#34;Verdana&#34;, 18), bg=&#39;#4CAF50&#39;, fg=&#39;white&#39;)
    signIn_button.place(relx=0.3, rely=0.9)</code></pre>
</details>
</dd>
<dt id="Presentation.SignUpPage.exitTheGame"><code class="name flex">
<span>def <span class="ident">exitTheGame</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>upon clicking the 'exit' button, handle exiting the game gracefully by sending a message
to the server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exitTheGame(self):
    &#34;&#34;&#34;upon clicking the &#39;exit&#39; button, handle exiting the game gracefully by sending a message
        to the server
    &#34;&#34;&#34;
    self.controller.messageChannel.setRequest(&#34;exit&#34;, &#34;a&#34;)</code></pre>
</details>
</dd>
<dt id="Presentation.SignUpPage.getNikNameEntry"><code class="name flex">
<span>def <span class="ident">getNikNameEntry</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the text in the 'insert token' entry</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>token, unique ID of the user</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getNikNameEntry(self):
    &#34;&#34;&#34;get the text in the &#39;insert token&#39; entry

    Returns:
        str: token, unique ID of the user
    &#34;&#34;&#34;
    return self.nikName_entry.get()</code></pre>
</details>
</dd>
<dt id="Presentation.SignUpPage.signUp_helper"><code class="name flex">
<span>def <span class="ident">signUp_helper</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>check if a response from the server about the signUp request has arrived.
At first we check if the response is None i.e. no response has arrived, and then we verify
that the response is what we expected to, i.e. "response" == "1_newUser", else we continue looping.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signUp_helper(self):
    &#34;&#34;&#34;check if a response from the server about the signUp request has arrived.
        At first we check if the response is None i.e. no response has arrived, and then we verify
        that the response is what we expected to, i.e. &#34;response&#34; == &#34;1_newUser&#34;, else we continue looping.
    &#34;&#34;&#34;
    while (self.controller.messageChannel.responses == []  or  
           self.controller.messageChannel.responses[0][&#34;response&#34;][0] != &#34;1&#34;):
        pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Presentation.StatisticsPage"><code class="flex name class">
<span>class <span class="ident">StatisticsPage</span></span>
<span>(</span><span>master, controller)</span>
</code></dt>
<dd>
<div class="desc"><p>page for displaying statistics about the games and users</p>
<p>constructor for SignUpPage</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>tk.Frame</code></dt>
<dd>a frame that inherits from the app root</dd>
<dt><strong><code>controller</code></strong> :&ensp;<code>AppRoot</code></dt>
<dd>the controller of the app</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatisticsPage(tk.Frame):
    &#34;&#34;&#34;page for displaying statistics about the games and users
    &#34;&#34;&#34;
    def __init__(self, master, controller):
        &#34;&#34;&#34;constructor for SignUpPage

        Args:
            parent (tk.Frame): a frame that inherits from the app root
            controller (AppRoot): the controller of the app
        &#34;&#34;&#34;
        tk.Frame.__init__(self, master)

        self.master = master
        self.controller = controller
        
        self.games = []
        self.users = []

        self.create_widgets() # call the function that create the graphical elements
        
        self.fetchInfo() # prepare the information for display


    def create_widgets(self):
        &#34;&#34;&#34;create the graphical elements and define their properties
        &#34;&#34;&#34;
        # create headline
        self.headline_label = ttk.Label(self, text=&#34;Game Statistics&#34;, font=(&#34;Helvetica&#34;, 30, &#34;bold&#34;), foreground=&#34;blue&#34;)
        self.headline_label.pack(pady=10)

        # create tabs (games and users)
        self.tabControl = ttk.Notebook(self)

        self.tab1 = ttk.Frame(self.tabControl)
        self.tabControl.add(self.tab1, text=&#34;Games&#34;)

        self.tab2 = ttk.Frame(self.tabControl)
        self.tabControl.add(self.tab2, text=&#34;Users&#34;)

        self.tabControl.pack(expand=1, fill=&#34;x&#34;)
        self.tabControl.bind(&#34;&lt;&lt;NotebookTabChanged&gt;&gt;&#34;, self.tab_changed)

        # create tables for games and users
        self.table1_frame = ttk.Frame(self)
        self.table1_frame.pack(fill=&#34;both&#34;, expand=1, padx=20, pady=10)

        self.table2_frame = ttk.Frame(self)
        self.table2_frame.pack(fill=&#34;both&#34;, expand=1, padx=20, pady=10)

        self.treeViewGames = ttk.Treeview(self.table1_frame, columns=(&#34;index&#34;, &#34;date&#34;, &#34;duration&#34;, &#34;num_of_players&#34;, &#34;status&#34;, &#34;winner&#34;), show=&#34;headings&#34;)
        self.treeViewGames.heading(&#34;index&#34;, text=&#34;#&#34;)
        self.treeViewGames.heading(&#34;date&#34;, text=&#34;date&#34;)
        self.treeViewGames.heading(&#34;duration&#34;, text=&#34;duration&#34;)
        self.treeViewGames.heading(&#34;num_of_players&#34;, text=&#34;number of players&#34;)
        self.treeViewGames.heading(&#34;status&#34;, text=&#34;status&#34;)
        self.treeViewGames.heading(&#34;winner&#34;, text=&#34;winner&#34;)

        self.treeViewGames.column(&#34;index&#34;, width=50, anchor=&#34;center&#34;)
        self.treeViewGames.column(&#34;date&#34;, width=150, anchor=&#34;center&#34;)
        self.treeViewGames.column(&#34;duration&#34;, width=50, anchor=&#34;center&#34;)
        self.treeViewGames.column(&#34;num_of_players&#34;, width=100, anchor=&#34;center&#34;)
        self.treeViewGames.column(&#34;status&#34;, width=50, anchor=&#34;center&#34;)
        self.treeViewGames.column(&#34;winner&#34;, width=150, anchor=&#34;center&#34;)

        self.treeViewUsers = ttk.Treeview(self.table2_frame, columns=(&#34;user_name&#34;, &#34;number_of_games&#34;, &#34;number_of_winnings&#34;, &#34;number_of_loses&#34;, &#34;number_of_draws&#34;), show=&#34;headings&#34;)
        self.treeViewUsers.heading(&#34;user_name&#34;, text=&#34;user name&#34;)
        self.treeViewUsers.heading(&#34;number_of_games&#34;, text=&#34;number of games&#34;)
        self.treeViewUsers.heading(&#34;number_of_winnings&#34;, text=&#34;won&#34;)
        self.treeViewUsers.heading(&#34;number_of_loses&#34;, text=&#34;lost&#34;)
        self.treeViewUsers.heading(&#34;number_of_draws&#34;, text=&#34;draw&#34;)

        self.treeViewUsers.column(&#34;user_name&#34;, width=150, anchor=&#34;center&#34;)
        self.treeViewUsers.column(&#34;number_of_games&#34;, width=100, anchor=&#34;center&#34;)
        self.treeViewUsers.column(&#34;number_of_winnings&#34;, width=100, anchor=&#34;center&#34;)
        self.treeViewUsers.column(&#34;number_of_loses&#34;, width=100, anchor=&#34;center&#34;)
        self.treeViewUsers.column(&#34;number_of_draws&#34;, width=100, anchor=&#34;center&#34;)

        self.treeViewGames.pack(side=&#34;left&#34;, fill=&#34;both&#34;, expand=True)
        self.treeViewUsers.pack(side=&#34;left&#34;, fill=&#34;both&#34;, expand=True)

        # create scroll bar for scrooling the information in the tables
        self.scrollbar1 = ttk.Scrollbar(self.table1_frame, orient=&#34;vertical&#34;, command=self.treeViewGames.yview)
        self.scrollbar1.pack(side=&#34;right&#34;, fill=&#34;y&#34;)
        self.treeViewGames.configure(yscroll=self.scrollbar1.set)

        self.scrollbar2 = ttk.Scrollbar(self.table2_frame, orient=&#34;vertical&#34;, command=self.treeViewUsers.yview)
        self.scrollbar2.pack(side=&#34;right&#34;, fill=&#34;y&#34;)
        self.treeViewUsers.configure(yscroll=self.scrollbar2.set)

        # hide the table of users at initialization
        self.table2_frame.pack_forget()

        # buttons frame
        self.button_frame = ttk.Frame(self)
        self.button_frame.pack(pady=10)
        
        # button for exiting the application
        self.exit_button = ttk.Button(self.button_frame, text=&#34;Exit&#34;, command=self.exitApp, width=10)
        self.exit_button.pack(side=&#34;left&#34;, padx=10)

        # button for getting out of the game
        self.back_button = ttk.Button(self.button_frame, text=&#34;Back to Main&#34;, command=lambda: self.controller.show_page(MainPage), width=15)
        self.back_button.pack(side=&#34;left&#34;, padx=10)
        

        # Initialize style
        s = ttk.Style()

        # Create style for the first frame
        s.configure(&#39;TFrame&#39;, background=&#39;#f0f0f0&#39;)
        
        self.configure(bg=&#34;#f0f0f0&#34;)
        self.headline_label.configure(background=&#34;#f0f0f0&#34;)

        
    def fetchInfo(self):
        &#34;&#34;&#34;send a request to the server for games history and users statistics
        &#34;&#34;&#34;
        self.controller.messageChannel.setRequest(&#34;fetchGamesHistory&#34;, &#34;&#34;)
        
        t = threading.Thread(target=self.gamesHistory_helper)
        t.start()
        # check periodically for a response from the server and handle a response in &#39;check_if_signUp_done&#39;
        schedule_check(self, t, self.check_if_gamesHistory_done.__name__)


    def gamesHistory_helper(self):
        &#34;&#34;&#34;check if a response from the server about the &#39;fetchGamesHistory&#39; request has arrived.
            At first we check if the response is None i.e. no response has arrived, and then we verify
            that the response is what we expected to, i.e. &#34;response&#34; == &#34;16_gamesHistory&#34;, else we continue looping.
        &#34;&#34;&#34;
        while (self.controller.messageChannel.responses == []  or
               self.controller.messageChannel.responses[0][&#34;response&#34;][0:2] != &#34;16&#34;):
            pass

    def check_if_gamesHistory_done(self, t):
        &#34;&#34;&#34;if the thread &#39;t&#39; is dead then it means a response from the server about the &#39;gamesHistory&#39; request has arrived,
            the function handle that response
        Args:
            t (Thread): the thread that is in charge of the gamesHistory response
        &#34;&#34;&#34;
        if not t.is_alive():
            games = self.controller.messageChannel.responses[0][&#34;value&#34;] # should be a list of lists: [... [game_ID: str, game: dict] ...]
            if self.controller.currentPage is StatisticsPage:
                self.games = games
                if games == []:
                    messagebox.showinfo(&#34;message&#34;, &#34;it seems like the server has no information about games statistics&#34;)
                self.populate_table(1) # populate the table of games with history of recent games
            
            # pop the handled response fron the queue of responses
            self.controller.messageChannel.responses.pop(0)
            # only after fetching history of games we fetch the statistics of users
            self.controller.messageChannel.setRequest(&#34;fetchUsersStats&#34;, &#34;&#34;)
        
            t = threading.Thread(target=self.usersStats_helper)
            t.start()
            # check periodically for a response from the server and handle a response in &#39;check_if_usersStat_done&#39;
            schedule_check(self, t, self.check_if_usersStats_done.__name__)

        else:
            # Otherwise check again after one second
            schedule_check(self, t, self.check_if_gamesHistory_done.__name__)
    
    def usersStats_helper(self):
        &#34;&#34;&#34;check if a response from the server about the &#39;fetchUsersStats&#39; request has arrived.
            At first we check if the response is None i.e. no response has arrived, and then we verify
            that the response is what we expected to, i.e. &#34;response&#34; == &#34;17_usersStats&#34;, else we continue looping.
        &#34;&#34;&#34;
        while (self.controller.messageChannel.responses == []  or
               self.controller.messageChannel.responses[0][&#34;response&#34;][0:2] != &#34;17&#34;):
            pass            

    def check_if_usersStats_done(self, t):
        &#34;&#34;&#34;if the thread &#39;t&#39; is dead then it means a response from the server about the &#39;userStats&#39; request has arrived,
            the function handle that response
        Args:
            t (Thread): the thread that is in charge of checking if &#39;userStats&#39; response has arrived
        &#34;&#34;&#34;
        if not t.is_alive():
            usersStats = self.controller.messageChannel.responses[0][&#34;value&#34;] # should be a list of items: (nik name: str, user: dict)
            if self.controller.currentPage is StatisticsPage:
                self.users = usersStats
                if usersStats == []:
                    messagebox.showinfo(&#34;message&#34;, &#34;it seems like the server has no information about user statistics&#34;)
                self.populate_table(2) # populate table of users

            # pop the handled response from the queue of responses
            self.controller.messageChannel.responses.pop(0)
        else:
            # Otherwise check again after one second
            schedule_check(self, t, self.check_if_usersStats_done.__name__)


    def populate_table(self, table: int):
        &#34;&#34;&#34;populate the table whose index is given as parameter &#39;table&#39;

        Args:
            table (int): 1 for the table of games, 2 for the table of users
        &#34;&#34;&#34;
        # Populate table with data based on the selected tab index
        if table == 1: # games
            for i, game in enumerate(self.games):
                # construct a date format
                date = datetime.datetime.fromisoformat(game[1][&#34;creation_date&#34;]).strftime(&#34;%d/%m/%Y&#34;)
                # duration in seconds
                duration_micro = str(datetime.timedelta(seconds = game[1][&#34;duration&#34;]))
                index = duration_micro.rfind(&#34;.&#34;)
                # throw the fragment of second after the dot
                duration = duration_micro if index == -1 else duration_micro[:index]
                if game[1][&#34;game_state&#34;] == &#39;WON&#39;:    
                    status = &#34;victory&#34;
                    winner = game[1][&#34;winner_name&#34;]
                else:
                    status = &#34;draw&#34;
                    winner = &#34;-&#34;
            
                self.treeViewGames.insert(&#34;&#34;, &#34;end&#34;, values=(str(i+1), date, duration, game[1][&#34;num_of_players&#34;], status, winner))
        else: # users
            self.table = self.treeViewUsers
            self.table.pack(side=&#34;left&#34;, fill=&#34;both&#34;, expand=True)
            for user in self.users:
                num_games = user[1][&#34;games_participated&#34;]
                victory = user[1][&#34;games_won&#34;]
                draw = user[1][&#34;games_tie&#34;]
                loses = num_games - victory - draw
                self.treeViewUsers.insert(&#34;&#34;, &#34;end&#34;, values=(user[0], num_games, victory, loses, draw))


    def tab_changed(self, event):
        &#34;&#34;&#34;handle event of changing tab in the listbox

        Args:
            event: click on one of the tabs
        &#34;&#34;&#34;
        # Get the index of the currently selected tab
        tab_index = self.tabControl.index(self.tabControl.select())

        if (tab_index == 0): # click on &#39;games&#39; tab
            # Update the content of the table based on the selected tab
            self.button_frame.pack_forget()
            self.table1_frame.pack(fill=&#34;both&#34;, expand=1, padx=20, pady=10)
            self.table2_frame.pack_forget()
            self.button_frame.pack(pady=10)
            
        else: # tab_changed = 1, click on &#39;users&#39; tab
            self.button_frame.pack_forget()
            self.table2_frame.pack(fill=&#34;both&#34;, expand=1, padx=20, pady=10)
            self.table1_frame.pack_forget()
            self.button_frame.pack(pady=10)


    def exitApp(self):
        &#34;&#34;&#34;upon clicking the &#39;exit&#39; button, handle exiting the game gracefully by sending a message
            to the server
        &#34;&#34;&#34;
        self.controller.messageChannel.setRequest(&#34;exit&#34;, &#34;a&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Frame</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Presentation.StatisticsPage.check_if_gamesHistory_done"><code class="name flex">
<span>def <span class="ident">check_if_gamesHistory_done</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"><p>if the thread 't' is dead then it means a response from the server about the 'gamesHistory' request has arrived,
the function handle that response</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>Thread</code></dt>
<dd>the thread that is in charge of the gamesHistory response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_if_gamesHistory_done(self, t):
    &#34;&#34;&#34;if the thread &#39;t&#39; is dead then it means a response from the server about the &#39;gamesHistory&#39; request has arrived,
        the function handle that response
    Args:
        t (Thread): the thread that is in charge of the gamesHistory response
    &#34;&#34;&#34;
    if not t.is_alive():
        games = self.controller.messageChannel.responses[0][&#34;value&#34;] # should be a list of lists: [... [game_ID: str, game: dict] ...]
        if self.controller.currentPage is StatisticsPage:
            self.games = games
            if games == []:
                messagebox.showinfo(&#34;message&#34;, &#34;it seems like the server has no information about games statistics&#34;)
            self.populate_table(1) # populate the table of games with history of recent games
        
        # pop the handled response fron the queue of responses
        self.controller.messageChannel.responses.pop(0)
        # only after fetching history of games we fetch the statistics of users
        self.controller.messageChannel.setRequest(&#34;fetchUsersStats&#34;, &#34;&#34;)
    
        t = threading.Thread(target=self.usersStats_helper)
        t.start()
        # check periodically for a response from the server and handle a response in &#39;check_if_usersStat_done&#39;
        schedule_check(self, t, self.check_if_usersStats_done.__name__)

    else:
        # Otherwise check again after one second
        schedule_check(self, t, self.check_if_gamesHistory_done.__name__)</code></pre>
</details>
</dd>
<dt id="Presentation.StatisticsPage.check_if_usersStats_done"><code class="name flex">
<span>def <span class="ident">check_if_usersStats_done</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"><p>if the thread 't' is dead then it means a response from the server about the 'userStats' request has arrived,
the function handle that response</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>Thread</code></dt>
<dd>the thread that is in charge of checking if 'userStats' response has arrived</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_if_usersStats_done(self, t):
    &#34;&#34;&#34;if the thread &#39;t&#39; is dead then it means a response from the server about the &#39;userStats&#39; request has arrived,
        the function handle that response
    Args:
        t (Thread): the thread that is in charge of checking if &#39;userStats&#39; response has arrived
    &#34;&#34;&#34;
    if not t.is_alive():
        usersStats = self.controller.messageChannel.responses[0][&#34;value&#34;] # should be a list of items: (nik name: str, user: dict)
        if self.controller.currentPage is StatisticsPage:
            self.users = usersStats
            if usersStats == []:
                messagebox.showinfo(&#34;message&#34;, &#34;it seems like the server has no information about user statistics&#34;)
            self.populate_table(2) # populate table of users

        # pop the handled response from the queue of responses
        self.controller.messageChannel.responses.pop(0)
    else:
        # Otherwise check again after one second
        schedule_check(self, t, self.check_if_usersStats_done.__name__)</code></pre>
</details>
</dd>
<dt id="Presentation.StatisticsPage.create_widgets"><code class="name flex">
<span>def <span class="ident">create_widgets</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>create the graphical elements and define their properties</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_widgets(self):
    &#34;&#34;&#34;create the graphical elements and define their properties
    &#34;&#34;&#34;
    # create headline
    self.headline_label = ttk.Label(self, text=&#34;Game Statistics&#34;, font=(&#34;Helvetica&#34;, 30, &#34;bold&#34;), foreground=&#34;blue&#34;)
    self.headline_label.pack(pady=10)

    # create tabs (games and users)
    self.tabControl = ttk.Notebook(self)

    self.tab1 = ttk.Frame(self.tabControl)
    self.tabControl.add(self.tab1, text=&#34;Games&#34;)

    self.tab2 = ttk.Frame(self.tabControl)
    self.tabControl.add(self.tab2, text=&#34;Users&#34;)

    self.tabControl.pack(expand=1, fill=&#34;x&#34;)
    self.tabControl.bind(&#34;&lt;&lt;NotebookTabChanged&gt;&gt;&#34;, self.tab_changed)

    # create tables for games and users
    self.table1_frame = ttk.Frame(self)
    self.table1_frame.pack(fill=&#34;both&#34;, expand=1, padx=20, pady=10)

    self.table2_frame = ttk.Frame(self)
    self.table2_frame.pack(fill=&#34;both&#34;, expand=1, padx=20, pady=10)

    self.treeViewGames = ttk.Treeview(self.table1_frame, columns=(&#34;index&#34;, &#34;date&#34;, &#34;duration&#34;, &#34;num_of_players&#34;, &#34;status&#34;, &#34;winner&#34;), show=&#34;headings&#34;)
    self.treeViewGames.heading(&#34;index&#34;, text=&#34;#&#34;)
    self.treeViewGames.heading(&#34;date&#34;, text=&#34;date&#34;)
    self.treeViewGames.heading(&#34;duration&#34;, text=&#34;duration&#34;)
    self.treeViewGames.heading(&#34;num_of_players&#34;, text=&#34;number of players&#34;)
    self.treeViewGames.heading(&#34;status&#34;, text=&#34;status&#34;)
    self.treeViewGames.heading(&#34;winner&#34;, text=&#34;winner&#34;)

    self.treeViewGames.column(&#34;index&#34;, width=50, anchor=&#34;center&#34;)
    self.treeViewGames.column(&#34;date&#34;, width=150, anchor=&#34;center&#34;)
    self.treeViewGames.column(&#34;duration&#34;, width=50, anchor=&#34;center&#34;)
    self.treeViewGames.column(&#34;num_of_players&#34;, width=100, anchor=&#34;center&#34;)
    self.treeViewGames.column(&#34;status&#34;, width=50, anchor=&#34;center&#34;)
    self.treeViewGames.column(&#34;winner&#34;, width=150, anchor=&#34;center&#34;)

    self.treeViewUsers = ttk.Treeview(self.table2_frame, columns=(&#34;user_name&#34;, &#34;number_of_games&#34;, &#34;number_of_winnings&#34;, &#34;number_of_loses&#34;, &#34;number_of_draws&#34;), show=&#34;headings&#34;)
    self.treeViewUsers.heading(&#34;user_name&#34;, text=&#34;user name&#34;)
    self.treeViewUsers.heading(&#34;number_of_games&#34;, text=&#34;number of games&#34;)
    self.treeViewUsers.heading(&#34;number_of_winnings&#34;, text=&#34;won&#34;)
    self.treeViewUsers.heading(&#34;number_of_loses&#34;, text=&#34;lost&#34;)
    self.treeViewUsers.heading(&#34;number_of_draws&#34;, text=&#34;draw&#34;)

    self.treeViewUsers.column(&#34;user_name&#34;, width=150, anchor=&#34;center&#34;)
    self.treeViewUsers.column(&#34;number_of_games&#34;, width=100, anchor=&#34;center&#34;)
    self.treeViewUsers.column(&#34;number_of_winnings&#34;, width=100, anchor=&#34;center&#34;)
    self.treeViewUsers.column(&#34;number_of_loses&#34;, width=100, anchor=&#34;center&#34;)
    self.treeViewUsers.column(&#34;number_of_draws&#34;, width=100, anchor=&#34;center&#34;)

    self.treeViewGames.pack(side=&#34;left&#34;, fill=&#34;both&#34;, expand=True)
    self.treeViewUsers.pack(side=&#34;left&#34;, fill=&#34;both&#34;, expand=True)

    # create scroll bar for scrooling the information in the tables
    self.scrollbar1 = ttk.Scrollbar(self.table1_frame, orient=&#34;vertical&#34;, command=self.treeViewGames.yview)
    self.scrollbar1.pack(side=&#34;right&#34;, fill=&#34;y&#34;)
    self.treeViewGames.configure(yscroll=self.scrollbar1.set)

    self.scrollbar2 = ttk.Scrollbar(self.table2_frame, orient=&#34;vertical&#34;, command=self.treeViewUsers.yview)
    self.scrollbar2.pack(side=&#34;right&#34;, fill=&#34;y&#34;)
    self.treeViewUsers.configure(yscroll=self.scrollbar2.set)

    # hide the table of users at initialization
    self.table2_frame.pack_forget()

    # buttons frame
    self.button_frame = ttk.Frame(self)
    self.button_frame.pack(pady=10)
    
    # button for exiting the application
    self.exit_button = ttk.Button(self.button_frame, text=&#34;Exit&#34;, command=self.exitApp, width=10)
    self.exit_button.pack(side=&#34;left&#34;, padx=10)

    # button for getting out of the game
    self.back_button = ttk.Button(self.button_frame, text=&#34;Back to Main&#34;, command=lambda: self.controller.show_page(MainPage), width=15)
    self.back_button.pack(side=&#34;left&#34;, padx=10)
    

    # Initialize style
    s = ttk.Style()

    # Create style for the first frame
    s.configure(&#39;TFrame&#39;, background=&#39;#f0f0f0&#39;)
    
    self.configure(bg=&#34;#f0f0f0&#34;)
    self.headline_label.configure(background=&#34;#f0f0f0&#34;)</code></pre>
</details>
</dd>
<dt id="Presentation.StatisticsPage.exitApp"><code class="name flex">
<span>def <span class="ident">exitApp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>upon clicking the 'exit' button, handle exiting the game gracefully by sending a message
to the server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exitApp(self):
    &#34;&#34;&#34;upon clicking the &#39;exit&#39; button, handle exiting the game gracefully by sending a message
        to the server
    &#34;&#34;&#34;
    self.controller.messageChannel.setRequest(&#34;exit&#34;, &#34;a&#34;)</code></pre>
</details>
</dd>
<dt id="Presentation.StatisticsPage.fetchInfo"><code class="name flex">
<span>def <span class="ident">fetchInfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>send a request to the server for games history and users statistics</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetchInfo(self):
    &#34;&#34;&#34;send a request to the server for games history and users statistics
    &#34;&#34;&#34;
    self.controller.messageChannel.setRequest(&#34;fetchGamesHistory&#34;, &#34;&#34;)
    
    t = threading.Thread(target=self.gamesHistory_helper)
    t.start()
    # check periodically for a response from the server and handle a response in &#39;check_if_signUp_done&#39;
    schedule_check(self, t, self.check_if_gamesHistory_done.__name__)</code></pre>
</details>
</dd>
<dt id="Presentation.StatisticsPage.gamesHistory_helper"><code class="name flex">
<span>def <span class="ident">gamesHistory_helper</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>check if a response from the server about the 'fetchGamesHistory' request has arrived.
At first we check if the response is None i.e. no response has arrived, and then we verify
that the response is what we expected to, i.e. "response" == "16_gamesHistory", else we continue looping.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gamesHistory_helper(self):
    &#34;&#34;&#34;check if a response from the server about the &#39;fetchGamesHistory&#39; request has arrived.
        At first we check if the response is None i.e. no response has arrived, and then we verify
        that the response is what we expected to, i.e. &#34;response&#34; == &#34;16_gamesHistory&#34;, else we continue looping.
    &#34;&#34;&#34;
    while (self.controller.messageChannel.responses == []  or
           self.controller.messageChannel.responses[0][&#34;response&#34;][0:2] != &#34;16&#34;):
        pass</code></pre>
</details>
</dd>
<dt id="Presentation.StatisticsPage.populate_table"><code class="name flex">
<span>def <span class="ident">populate_table</span></span>(<span>self, table:int)</span>
</code></dt>
<dd>
<div class="desc"><p>populate the table whose index is given as parameter 'table'</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>int</code></dt>
<dd>1 for the table of games, 2 for the table of users</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate_table(self, table: int):
    &#34;&#34;&#34;populate the table whose index is given as parameter &#39;table&#39;

    Args:
        table (int): 1 for the table of games, 2 for the table of users
    &#34;&#34;&#34;
    # Populate table with data based on the selected tab index
    if table == 1: # games
        for i, game in enumerate(self.games):
            # construct a date format
            date = datetime.datetime.fromisoformat(game[1][&#34;creation_date&#34;]).strftime(&#34;%d/%m/%Y&#34;)
            # duration in seconds
            duration_micro = str(datetime.timedelta(seconds = game[1][&#34;duration&#34;]))
            index = duration_micro.rfind(&#34;.&#34;)
            # throw the fragment of second after the dot
            duration = duration_micro if index == -1 else duration_micro[:index]
            if game[1][&#34;game_state&#34;] == &#39;WON&#39;:    
                status = &#34;victory&#34;
                winner = game[1][&#34;winner_name&#34;]
            else:
                status = &#34;draw&#34;
                winner = &#34;-&#34;
        
            self.treeViewGames.insert(&#34;&#34;, &#34;end&#34;, values=(str(i+1), date, duration, game[1][&#34;num_of_players&#34;], status, winner))
    else: # users
        self.table = self.treeViewUsers
        self.table.pack(side=&#34;left&#34;, fill=&#34;both&#34;, expand=True)
        for user in self.users:
            num_games = user[1][&#34;games_participated&#34;]
            victory = user[1][&#34;games_won&#34;]
            draw = user[1][&#34;games_tie&#34;]
            loses = num_games - victory - draw
            self.treeViewUsers.insert(&#34;&#34;, &#34;end&#34;, values=(user[0], num_games, victory, loses, draw))</code></pre>
</details>
</dd>
<dt id="Presentation.StatisticsPage.tab_changed"><code class="name flex">
<span>def <span class="ident">tab_changed</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>handle event of changing tab in the listbox</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong></dt>
<dd>click on one of the tabs</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tab_changed(self, event):
    &#34;&#34;&#34;handle event of changing tab in the listbox

    Args:
        event: click on one of the tabs
    &#34;&#34;&#34;
    # Get the index of the currently selected tab
    tab_index = self.tabControl.index(self.tabControl.select())

    if (tab_index == 0): # click on &#39;games&#39; tab
        # Update the content of the table based on the selected tab
        self.button_frame.pack_forget()
        self.table1_frame.pack(fill=&#34;both&#34;, expand=1, padx=20, pady=10)
        self.table2_frame.pack_forget()
        self.button_frame.pack(pady=10)
        
    else: # tab_changed = 1, click on &#39;users&#39; tab
        self.button_frame.pack_forget()
        self.table2_frame.pack(fill=&#34;both&#34;, expand=1, padx=20, pady=10)
        self.table1_frame.pack_forget()
        self.button_frame.pack(pady=10)</code></pre>
</details>
</dd>
<dt id="Presentation.StatisticsPage.usersStats_helper"><code class="name flex">
<span>def <span class="ident">usersStats_helper</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>check if a response from the server about the 'fetchUsersStats' request has arrived.
At first we check if the response is None i.e. no response has arrived, and then we verify
that the response is what we expected to, i.e. "response" == "17_usersStats", else we continue looping.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def usersStats_helper(self):
    &#34;&#34;&#34;check if a response from the server about the &#39;fetchUsersStats&#39; request has arrived.
        At first we check if the response is None i.e. no response has arrived, and then we verify
        that the response is what we expected to, i.e. &#34;response&#34; == &#34;17_usersStats&#34;, else we continue looping.
    &#34;&#34;&#34;
    while (self.controller.messageChannel.responses == []  or
           self.controller.messageChannel.responses[0][&#34;response&#34;][0:2] != &#34;17&#34;):
        pass            </code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="Presentation.schedule_check" href="#Presentation.schedule_check">schedule_check</a></code></li>
<li><code><a title="Presentation.validate_numbers_entry" href="#Presentation.validate_numbers_entry">validate_numbers_entry</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Presentation.AuthPageToken" href="#Presentation.AuthPageToken">AuthPageToken</a></code></h4>
<ul class="">
<li><code><a title="Presentation.AuthPageToken.authenticate" href="#Presentation.AuthPageToken.authenticate">authenticate</a></code></li>
<li><code><a title="Presentation.AuthPageToken.authenticate_helper" href="#Presentation.AuthPageToken.authenticate_helper">authenticate_helper</a></code></li>
<li><code><a title="Presentation.AuthPageToken.check_if_auth_done" href="#Presentation.AuthPageToken.check_if_auth_done">check_if_auth_done</a></code></li>
<li><code><a title="Presentation.AuthPageToken.create_widgets" href="#Presentation.AuthPageToken.create_widgets">create_widgets</a></code></li>
<li><code><a title="Presentation.AuthPageToken.exitTheGame" href="#Presentation.AuthPageToken.exitTheGame">exitTheGame</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Presentation.GamePage" href="#Presentation.GamePage">GamePage</a></code></h4>
<ul class="">
<li><code><a title="Presentation.GamePage.add_message" href="#Presentation.GamePage.add_message">add_message</a></code></li>
<li><code><a title="Presentation.GamePage.assignSymbol" href="#Presentation.GamePage.assignSymbol">assignSymbol</a></code></li>
<li><code><a title="Presentation.GamePage.create_widgets" href="#Presentation.GamePage.create_widgets">create_widgets</a></code></li>
<li><code><a title="Presentation.GamePage.exit_app" href="#Presentation.GamePage.exit_app">exit_app</a></code></li>
<li><code><a title="Presentation.GamePage.on_button_click" href="#Presentation.GamePage.on_button_click">on_button_click</a></code></li>
<li><code><a title="Presentation.GamePage.quit_game" href="#Presentation.GamePage.quit_game">quit_game</a></code></li>
<li><code><a title="Presentation.GamePage.restartTimer" href="#Presentation.GamePage.restartTimer">restartTimer</a></code></li>
<li><code><a title="Presentation.GamePage.updateBoardAndButton" href="#Presentation.GamePage.updateBoardAndButton">updateBoardAndButton</a></code></li>
<li><code><a title="Presentation.GamePage.update_timer_and_messages" href="#Presentation.GamePage.update_timer_and_messages">update_timer_and_messages</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Presentation.MainPage" href="#Presentation.MainPage">MainPage</a></code></h4>
<ul class="">
<li><code><a title="Presentation.MainPage.check_if_fetchActiveGames_done" href="#Presentation.MainPage.check_if_fetchActiveGames_done">check_if_fetchActiveGames_done</a></code></li>
<li><code><a title="Presentation.MainPage.check_if_newGame_done" href="#Presentation.MainPage.check_if_newGame_done">check_if_newGame_done</a></code></li>
<li><code><a title="Presentation.MainPage.create_widgets" href="#Presentation.MainPage.create_widgets">create_widgets</a></code></li>
<li><code><a title="Presentation.MainPage.exit_app" href="#Presentation.MainPage.exit_app">exit_app</a></code></li>
<li><code><a title="Presentation.MainPage.fetchActiveGames_helper" href="#Presentation.MainPage.fetchActiveGames_helper">fetchActiveGames_helper</a></code></li>
<li><code><a title="Presentation.MainPage.handle_radio_click" href="#Presentation.MainPage.handle_radio_click">handle_radio_click</a></code></li>
<li><code><a title="Presentation.MainPage.join_game" href="#Presentation.MainPage.join_game">join_game</a></code></li>
<li><code><a title="Presentation.MainPage.logout" href="#Presentation.MainPage.logout">logout</a></code></li>
<li><code><a title="Presentation.MainPage.newGame_helper" href="#Presentation.MainPage.newGame_helper">newGame_helper</a></code></li>
<li><code><a title="Presentation.MainPage.new_game" href="#Presentation.MainPage.new_game">new_game</a></code></li>
<li><code><a title="Presentation.MainPage.on_game_select" href="#Presentation.MainPage.on_game_select">on_game_select</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Presentation.SignUpPage" href="#Presentation.SignUpPage">SignUpPage</a></code></h4>
<ul class="">
<li><code><a title="Presentation.SignUpPage.check_if_signUp_done" href="#Presentation.SignUpPage.check_if_signUp_done">check_if_signUp_done</a></code></li>
<li><code><a title="Presentation.SignUpPage.createUser" href="#Presentation.SignUpPage.createUser">createUser</a></code></li>
<li><code><a title="Presentation.SignUpPage.create_widgets" href="#Presentation.SignUpPage.create_widgets">create_widgets</a></code></li>
<li><code><a title="Presentation.SignUpPage.exitTheGame" href="#Presentation.SignUpPage.exitTheGame">exitTheGame</a></code></li>
<li><code><a title="Presentation.SignUpPage.getNikNameEntry" href="#Presentation.SignUpPage.getNikNameEntry">getNikNameEntry</a></code></li>
<li><code><a title="Presentation.SignUpPage.signUp_helper" href="#Presentation.SignUpPage.signUp_helper">signUp_helper</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Presentation.StatisticsPage" href="#Presentation.StatisticsPage">StatisticsPage</a></code></h4>
<ul class="">
<li><code><a title="Presentation.StatisticsPage.check_if_gamesHistory_done" href="#Presentation.StatisticsPage.check_if_gamesHistory_done">check_if_gamesHistory_done</a></code></li>
<li><code><a title="Presentation.StatisticsPage.check_if_usersStats_done" href="#Presentation.StatisticsPage.check_if_usersStats_done">check_if_usersStats_done</a></code></li>
<li><code><a title="Presentation.StatisticsPage.create_widgets" href="#Presentation.StatisticsPage.create_widgets">create_widgets</a></code></li>
<li><code><a title="Presentation.StatisticsPage.exitApp" href="#Presentation.StatisticsPage.exitApp">exitApp</a></code></li>
<li><code><a title="Presentation.StatisticsPage.fetchInfo" href="#Presentation.StatisticsPage.fetchInfo">fetchInfo</a></code></li>
<li><code><a title="Presentation.StatisticsPage.gamesHistory_helper" href="#Presentation.StatisticsPage.gamesHistory_helper">gamesHistory_helper</a></code></li>
<li><code><a title="Presentation.StatisticsPage.populate_table" href="#Presentation.StatisticsPage.populate_table">populate_table</a></code></li>
<li><code><a title="Presentation.StatisticsPage.tab_changed" href="#Presentation.StatisticsPage.tab_changed">tab_changed</a></code></li>
<li><code><a title="Presentation.StatisticsPage.usersStats_helper" href="#Presentation.StatisticsPage.usersStats_helper">usersStats_helper</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>